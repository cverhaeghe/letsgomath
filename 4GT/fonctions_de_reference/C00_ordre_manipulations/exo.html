<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>


<div class="exo-container">
  <h1>Exercice</h1>

<div class="equation-box" id="equation"></div>

<div id="zone-propositions" class="order-container"></div>

<div class="center-button">
  <button onclick="verifier()">Valider</button>
  <button onclick="corriger()">Solution</button>
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>

  <div class="exo-links">
    <a href="../../4GT_geo_analytique.html">Retour au menu</a>
  </div>
</div>

<script>
/* ========================= Fonctions de référence ========================= */
let tentatives = 0;

const fonctions = [
  {nom:"carrée", latex:"f(x)=x^2"},
  {nom:"cube", latex:"f(x)=x^3"},
  {nom:"racine carrée", latex:"f(x)=\\sqrt{x}"},
  {nom:"racine cubique", latex:"f(x)=\\sqrt[3]{x}"},
  {nom:"valeur absolue", latex:"f(x)=|x|"},
  {nom:"inverse", latex:"f(x)=\\dfrac{1}{x}"}
];

 function appliquerFonction(flatex, interieur){

/* PUISSANCE 2 */
if(flatex.includes("x^2")){
  if(interieur.startsWith("(") && interieur.endsWith(")"))
    return `${interieur}^2`;
  else
    return `(${interieur})^2`;
}

/* PUISSANCE 3 */
if(flatex.includes("x^3")){
  if(interieur.startsWith("(") && interieur.endsWith(")"))
    return `${interieur}^3`;
  else
    return `(${interieur})^3`;
}


  /* RACINE CARRÉE */
  if(flatex.includes("\\sqrt{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\sqrt{${interieur}}`;
  }

  /* RACINE CUBIQUE */
  if(flatex.includes("\\sqrt[3]{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\sqrt[3]{${interieur}}`;
  }

  /* VALEUR ABSOLUE */
  if(flatex.includes("|x|")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\left|${interieur}\\right|`;
  }

  /* INVERSE */
  if(flatex.includes("\\dfrac{1}{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\dfrac{1}{${interieur}}`;
  }
}



/* ========================= Génération fractions ========================= */

function randomChoice(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}

function randomSign(){
  return Math.random() < 0.5 ? -1 : 1;
}

function randomK(){
  const valeurs = [1/2, 1/3, 2, 3];
  return randomSign() * randomChoice(valeurs);
}

function randomS(){
  const valeurs = [1/2, 1/3, 2, 3];
  return randomSign() * randomChoice(valeurs);
}


function toLatex(n){
  if(n===0) return "0";
  if(n===1) return "1";
  if(n===-1) return "-1";
  if(Math.abs(n)===0.5) return (n<0?"-":"")+"\\dfrac{1}{2}";
  if(Math.abs(n)===1/3) return (n<0?"-":"")+"\\dfrac{1}{3}";
  return n.toString();
}


/* ========================= Génération énoncé ========================= */

let bonneReponse = [];

  function compterTransformations(k,s,h,v){

  let count = 0;

  if(h !== 0) count++;
  if(v !== 0) count++;

  if(s !== 1){
    count++;                 // déformation horizontale
    if(s < 0) count++;       // symétrie y
  }

  if(k !== 1){
    count++;                 // déformation verticale
    if(k < 0) count++;       // symétrie x
  }

  return count;
}

  
function genererEquation(){

  tentatives = 0;

  document.getElementById("zone-propositions").innerHTML = "";

  const f = randomChoice(fonctions);

  let h = Math.floor(Math.random()*6)-3;
  let v = Math.floor(Math.random()*6)-3;

  let k, s;

/* choisir le type de transformation */
if(Math.random() < 0.5){
  /* cas transformation verticale */
  k = randomK();
  s = randomSign();   // ±1
}
else{
  /* cas transformation horizontale */

  if(f.latex.includes("\\dfrac{1}{x}")){
    /* fonction inverse → pas de déformations horizontales */
    const valeurs = [1,2,3];
    s = randomSign() * randomChoice(valeurs);
  }
  else{
    s = randomS();  // normal
  }

  k = randomSign();   // ±1
}


  if(s===0) s=1;
  if(k===0) k=1;

/* forcer au moins 2 transformations */
while(compterTransformations(k,s,h,v) < 2){

  h = Math.floor(Math.random()*6)-3;
  v = Math.floor(Math.random()*6)-3;

  if(Math.random() < 0.5){
    k = randomK();
    s = randomSign();
  }
  else{
    s = randomS();
    k = randomSign();
  }
}
  
  /* Expression latex */
let base = "";

if(h === 0)
  base = "x";
else
  base = `(x${h>0?"-"+h:"+"+(-h)})`;

let interieur = "";

/* cas s = 1 ou -1 */
if(s === 1)
  interieur = base;

else if(s === -1)
  interieur = `-${base}`;

/* cas fractions horizontales sans parenthèses inutiles */
else if(s === 1/2)
  interieur = `\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{2}`;

else if(s === -1/2)
  interieur = `-\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{2}`;

else if(s === 1/3)
  interieur = `\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{3}`;

else if(s === -1/3)
  interieur = `-\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{3}`;


/* autres cas */
else{
  if(base === "x")
    interieur = `${toLatex(s)}x`;
  else
    interieur = `${toLatex(s)}${base}`;
}



let fonctionTransformee = appliquerFonction(f.latex, interieur);

let expr = "";

/* k = 1 → on n'affiche rien */
if(k === 1){
  expr = `f(x)=${fonctionTransformee}`;
}

/* k = -1 → seulement le signe - */
else if(k === -1){
  expr = `f(x)=-${fonctionTransformee}`;
}

/* fractions verticales */
else if(k === 1/2){
  expr = `f(x)=\\dfrac{${fonctionTransformee}}{2}`;
}
else if(k === -1/2){
  expr = `f(x)=-\\dfrac{${fonctionTransformee}}{2}`;
}
else if(k === 1/3){
  expr = `f(x)=\\dfrac{${fonctionTransformee}}{3}`;
}
else if(k === -1/3){
  expr = `f(x)=-\\dfrac{${fonctionTransformee}}{3}`;
}

/* cas k = 2 ou 3 */
else{

  /* écriture spéciale pour la fonction inverse */
  if(f.latex.includes("\\dfrac{1}{x}")){
    
    let denom = fonctionTransformee
      .replace("\\dfrac{1}{","")
      .slice(0,-1);   // enlève l'accolade finale

    expr = `f(x)=\\dfrac{${toLatex(k)}}{${denom}}`;
  }
  else{
    expr = `f(x)=${toLatex(k)}${fonctionTransformee}`;
  }
}


/* translation verticale */
if(v !== 0){
  expr += v>0 ? `+${v}` : `${v}`;
}




  document.getElementById("equation").innerHTML =
    `Détermine l'ordre des transformations qu'a subit la fonction de référence :<br><br>
     \\(${expr}\\)`;

  MathJax.typeset();

  genererTransformations(k,s,h,v);
}


/* ========================= Création des transformations ========================= */

function genererTransformations(k,s,h,v){

  let liste = [];

  if(h!==0){
const hval = Math.abs(h);
const uniteH = hval === 1 ? "unité" : "unités";

liste.push(
  h>0 ?
  `Translation horizontale de ${hval} ${uniteH} vers la droite`
  :
  `Translation horizontale de ${hval} ${uniteH} vers la gauche`
);
  }

if(s !== 1){

    if(s < 0){
        liste.push(`Symétrie orthogonale d'axe y`);
    }

    const svaleur = Math.abs(s);

    if(svaleur === 2 || svaleur === 3){
        liste.push(`Compression horizontale de facteur ${svaleur}`);
    }
    else if(svaleur === 0.5 || svaleur === 1/3){
    const sfacteur = 1 / svaleur;   // inverse
    liste.push(`Étirement horizontal de facteur ${sfacteur}`);
}
}
  
if(k !== 1){

    if(k < 0){
        liste.push(`Symétrie orthogonale d'axe x`);
    }

    const kvaleur = Math.abs(k);

    if(kvaleur === 2 || kvaleur === 3){
        liste.push(`Étirement vertical de facteur ${kvaleur}`);
    }
    else if(kvaleur === 0.5 || kvaleur === 1/3){
        const kfacteur = 1 / kvaleur;   // inverse
        liste.push(`Compression verticale de facteur ${kfacteur}`);
    }
}


  if(v!==0){
const vval = Math.abs(v);
const uniteV = vval === 1 ? "unité" : "unités";

liste.push(
  v>0 ?
  `Translation verticale de ${vval} ${uniteV} vers le haut`
  :
  `Translation verticale de ${vval} ${uniteV} vers le bas`
);
  }

  bonneReponse = [...liste];

  /* Mélange */
  liste.sort(()=>Math.random()-0.5);

  /* sécurité : s'il n'y a aucune transformation, on en met au moins une */
if(liste.length === 0){
  liste.push("Aucune transformation");
}

  afficherChoix(liste);
}


/* =========================   Affichage (ordre à choisir) ========================= */

function afficherChoix(liste){

  const zone = document.getElementById("zone-propositions");

  /* sécurité : si la zone n'existe pas */
  if(!zone) return;

  /* vider complètement */
  zone.innerHTML = "";

  /* si aucune transformation (cas rare) */
  if(liste.length === 0){
    zone.innerHTML = "<i>Aucune transformation</i>";
    return;
  }

  /* recréer toutes les cartes */
  liste.forEach((texte,i)=>{
    const div = document.createElement("div");
    div.className = "order-item";
    div.draggable = true;
    div.textContent = texte;
    zone.appendChild(div);
  });

  activerDragDrop();
}


function activerDragDrop(){

  const items = document.querySelectorAll(".order-item");
  let dragged = null;

  /* ================= DESKTOP (drag classique) ================= */

  items.forEach(item=>{

    item.addEventListener("dragstart", ()=>{
      dragged = item;
      item.classList.add("dragging");
    });

    item.addEventListener("dragend", ()=>{
      item.classList.remove("dragging");
    });

    item.addEventListener("dragover", e=>{
      e.preventDefault();
    });

    item.addEventListener("drop", e=>{
      e.preventDefault();
      if(dragged !== item){
        echanger(dragged, item);
      }
    });

  });

  /* ===============================
   DRAG TACTILE LONG PRESS (GSM)
=============================== */

let touchTimer = null;
let touchItem = null;
let offsetY = 0;

document.addEventListener("touchstart", function(e){

  const target = e.target.closest(".order-item");
  if(!target) return;

  touchItem = target;

  touchTimer = setTimeout(()=>{
    /* long press activé */
    target.classList.add("dragging");
    target.style.backgroundColor = "var(--peps)";
    target.style.color = "white";

    const rect = target.getBoundingClientRect();
    offsetY = e.touches[0].clientY - rect.top;

  }, 600);   // durée long press (ms)

}, {passive:false});


document.addEventListener("touchmove", function(e){

  if(!touchItem || !touchItem.classList.contains("dragging")) return;

  e.preventDefault();

  const y = e.touches[0].clientY - offsetY;
  touchItem.style.position = "fixed";
  touchItem.style.left = "50%";
  touchItem.style.transform = "translateX(-50%)";
  touchItem.style.top = y + "px";
  touchItem.style.zIndex = 1000;

}, {passive:false});


document.addEventListener("touchend", function(e){

  clearTimeout(touchTimer);

  if(!touchItem) return;

  if(touchItem.classList.contains("dragging")){

    const items = [...document.querySelectorAll(".order-item")];
    const touchY = e.changedTouches[0].clientY;

    let closest = null;
    let minDist = Infinity;

    items.forEach(item=>{
      if(item === touchItem) return;
      const rect = item.getBoundingClientRect();
      const center = rect.top + rect.height/2;
      const dist = Math.abs(center - touchY);
      if(dist < minDist){
        minDist = dist;
        closest = item;
      }
    });

    if(closest){
      echanger(touchItem, closest);
    }
  }

  /* reset */
  if(touchItem){
    touchItem.classList.remove("dragging");
    touchItem.style.position = "";
    touchItem.style.top = "";
    touchItem.style.left = "";
    touchItem.style.transform = "";
    touchItem.style.zIndex = "";
    touchItem.style.backgroundColor = "";
    touchItem.style.color = "";
  }

  touchItem = null;

}, {passive:false});

  /* ================= MOBILE (tap → swap) ================= */

  let selected = null;

  items.forEach(item=>{

    item.addEventListener("click", ()=>{

      /* premier tap */
      if(!selected){
        selected = item;
        item.style.backgroundColor = "var(--peps)";
        item.style.color = "white";
        return;
      }

      /* deuxième tap → échange */
      if(selected !== item){
        echanger(selected, item);
      }

      /* reset */
      selected.style.backgroundColor = "";
      selected.style.color = "";
      selected = null;

    });

  });
}


/* échange de deux cartes */
function echanger(a, b){
  const parent = a.parentNode;
  const aNext = a.nextSibling === b ? a : a.nextSibling;
  parent.insertBefore(a, b);
  parent.insertBefore(b, aNext);
}



/* ========================= Vérification ========================= */

function verifier(){

  const items = document.querySelectorAll(".order-item");
  items.forEach(i=>i.classList.remove("correct","wrong"));

  let propositions = Array.from(items).map(i => i.textContent);
  let attendu = [...bonneReponse];

  let correct = comparerListes(propositions, attendu);

  if(correct){
    items.forEach(i=>i.classList.add("correct"));
    return;
  }

  tentatives++;

  items.forEach((item,i)=>{
    if(item.textContent === attendu[i])
      item.classList.add("correct");
    else
      item.classList.add("wrong");
  });

  if(tentatives >= 2){
    afficherCorrectionAutomatique();
  }
}

  function comparerListes(propositions, attendu){

  if(propositions.length !== attendu.length)
    return false;

  /* comparaison stricte */
  if(propositions.join() === attendu.join())
    return true;

  /* tolérance symétrie <-> dilatation */

  for(let i=0; i<attendu.length-1; i++){

    let a1 = attendu[i];
    let a2 = attendu[i+1];

    /* si symétrie + déformation verticale */
    if(
      (a1.includes("Symétrie orthogonale d'axe x") && a2.includes("verticale")) ||
      (a2.includes("Symétrie orthogonale d'axe x") && a1.includes("verticale"))
    ){

      let copie = [...attendu];
      [copie[i], copie[i+1]] = [copie[i+1], copie[i]];

      if(propositions.join() === copie.join())
        return true;
    }

    /* idem horizontal */
    if(
      (a1.includes("Symétrie orthogonale d'axe y") && a2.includes("horizontal")) ||
      (a2.includes("Symétrie orthogonale d'axe y") && a1.includes("horizontal"))
    ){

      let copie = [...attendu];
      [copie[i], copie[i+1]] = [copie[i+1], copie[i]];

      if(propositions.join() === copie.join())
        return true;
    }
  }

  return false;
}


function afficherCorrectionAutomatique(){

  const zone = document.getElementById("zone-propositions");
  zone.innerHTML = "";

  bonneReponse.forEach(t=>{
    const div = document.createElement("div");
    div.className = "order-item correct";
    div.textContent = t;
    zone.appendChild(div);
  });

  /* désactiver le bouton Valider */
  const boutons = document.querySelectorAll(".center-button button");
  boutons[0].disabled = true; // bouton Valider
}



/* ========================= Solution ========================= */

function corriger(){

  const zone = document.getElementById("zone-propositions");
  zone.innerHTML = "";

  bonneReponse.forEach(t=>{
    const div = document.createElement("div");
    div.className = "order-item correct";
    div.textContent = t;
    zone.appendChild(div);
  });
}



/* ======================== Génération initiale ========================= */

genererEquation();
</script>

   
  <!-- Protection clique droit (commun à tout le site) -->
  <script src="../../../js/protection.js"></script>
  
</body>
</html>

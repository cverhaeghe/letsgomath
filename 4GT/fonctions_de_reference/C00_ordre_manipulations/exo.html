<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>


<div class="exo-container">
  <h1>Exercice</h1>

<div class="equation-box" id="equation"></div>

<div id="zone-propositions" class="order-container"></div>

<div class="center-button">
  <button onclick="verifier()">Valider</button>
  <button onclick="corriger()">Solution</button>
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>

  <div class="exo-links">
    <a href="../../4GT_geo_analytique.html">Retour au menu</a>
  </div>
</div>

<script>
/* ========================= Fonctions de référence ========================= */

const fonctions = [
  {nom:"carrée", latex:"f(x)=x^2"},
  {nom:"cube", latex:"f(x)=x^3"},
  {nom:"racine carrée", latex:"f(x)=\\sqrt{x}"},
  {nom:"racine cubique", latex:"f(x)=\\sqrt[3]{x}"},
  {nom:"valeur absolue", latex:"f(x)=|x|"},
  {nom:"inverse", latex:"f(x)=\\frac{1}{x}"}
];

 function appliquerFonction(flatex, interieur){

  /* PUISSANCES → parenthèses nécessaires */
  if(flatex.includes("x^2"))
    return `(${interieur})^2`;

  if(flatex.includes("x^3"))
    return `(${interieur})^3`;

  /* RACINE CARRÉE */
  if(flatex.includes("\\sqrt{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\sqrt{${interieur}}`;
  }

  /* RACINE CUBIQUE */
  if(flatex.includes("\\sqrt[3]{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\sqrt[3]{${interieur}}`;
  }

  /* VALEUR ABSOLUE */
  if(flatex.includes("|x|")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\left|${interieur}\\right|`;
  }

  /* INVERSE */
  if(flatex.includes("\\dfrac{1}{x}")){
    if(interieur.startsWith("(") && interieur.endsWith(")"))
      interieur = interieur.slice(1,-1);
    return `\\frac{1}{${interieur}}`;
  }
}



/* ========================= Génération fractions ========================= */

function randomChoice(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}

function randomSign(){
  return Math.random() < 0.5 ? -1 : 1;
}

function randomK(){
  const valeurs = [1/2, 1/3, 2, 3];
  return randomSign() * randomChoice(valeurs);
}

function randomS(){
  const valeurs = [1/2, 1/3, 2, 3];
  return randomSign() * randomChoice(valeurs);
}


function toLatex(n){
  if(n===0) return "0";
  if(n===1) return "1";
  if(n===-1) return "-1";
  if(Math.abs(n)===0.5) return (n<0?"-":"")+"\\dfrac{1}{2}";
  if(Math.abs(n)===1/3) return (n<0?"-":"")+"\\dfrac{1}{3}";
  return n.toString();
}


/* ========================= Génération énoncé ========================= */

let bonneReponse = [];

function genererEquation(){

  const f = randomChoice(fonctions);

  let h = Math.floor(Math.random()*6)-3;
  let v = Math.floor(Math.random()*6)-3;

  let k, s;

/* choisir le type de transformation */
if(Math.random() < 0.5){
  /* cas transformation verticale */
  k = randomK();
  s = randomSign();   // ±1
}
else{
  /* cas transformation horizontale */

  if(f.latex.includes("\\dfrac{1}{x}")){
    /* fonction inverse → pas de déformations horizontales */
    const valeurs = [1,2,3];
    s = randomSign() * randomChoice(valeurs);
  }
  else{
    s = randomS();  // normal
  }

  k = randomSign();   // ±1
}


  if(s===0) s=1;
  if(k===0) k=1;

  /* Expression latex */
let base = "";

if(h === 0)
  base = "x";
else
  base = `(x${h>0?"-"+h:"+"+(-h)})`;

let interieur = "";

/* cas s = 1 ou -1 */
if(s === 1)
  interieur = base;

else if(s === -1)
  interieur = `-${base}`;

/* cas fractions horizontales sans parenthèses inutiles */
else if(s === 1/2)
  interieur = `\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{2}`;

else if(s === -1/2)
  interieur = `-\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{2}`;

else if(s === 1/3)
  interieur = `\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{3}`;

else if(s === -1/3)
  interieur = `-\\dfrac{x${h>0?"-"+h:h<0?"+"+(-h):""}}{3}`;


/* autres cas */
else{
  if(base === "x")
    interieur = `${toLatex(s)}x`;
  else
    interieur = `${toLatex(s)}${base}`;
}



let fonctionTransformee = appliquerFonction(f.latex, interieur);

let expr = "";

/* k = 1 → on n'affiche rien */
if(k === 1){
  expr = `f(x)=${fonctionTransformee}`;
}

/* k = -1 → seulement le signe - */
else if(k === -1){
  expr = `f(x)=-${fonctionTransformee}`;
}

/* fractions verticales */
else if(k === 1/2){
  expr = `f(x)=\\dfrac{${fonctionTransformee}}{2}`;
}
else if(k === -1/2){
  expr = `f(x)=-\\dfrac{${fonctionTransformee}}{2}`;
}
else if(k === 1/3){
  expr = `f(x)=\\dfrac{${fonctionTransformee}}{3}`;
}
else if(k === -1/3){
  expr = `f(x)=-\\dfrac{${fonctionTransformee}}{3}`;
}

/* cas k = 2 ou 3 */
else{

  /* écriture spéciale pour la fonction inverse */
  if(f.latex.includes("\\dfrac{1}{x}")){
    
    let denom = fonctionTransformee
      .replace("\\dfrac{1}{","")
      .slice(0,-1);   // enlève l'accolade finale

    expr = `f(x)=\\frac{${toLatex(k)}}{${denom}}`;
  }
  else{
    expr = `f(x)=${toLatex(k)}${fonctionTransformee}`;
  }
}


/* translation verticale */
if(v !== 0){
  expr += v>0 ? `+${v}` : `${v}`;
}




  document.getElementById("equation").innerHTML =
    `Détermine l'ordre des transformations qu'a subit la fonction de référence :<br><br>
     \\(${expr}\\)`;

  MathJax.typeset();

  genererTransformations(k,s,h,v);
}


/* ========================= Création des transformations ========================= */

function genererTransformations(k,s,h,v){

  let liste = [];

  if(h!==0){
    liste.push(
      h>0 ?
      `Translation horizontale de ${h} unités vers la droite`
      :
      `Translation horizontale de ${-h} unités vers la gauche`
    );
  }

if(s !== 1){

    if(s < 0){
        liste.push(`Symétrie orthogonale d'axe y`);
    }

    const svaleur = Math.abs(s);

    if(svaleur === 2 || svaleur === 3){
        liste.push(`Compression horizontale de facteur ${svaleur}`);
    }
    else if(valeur === 0.5 || valeur === 1/3){
        liste.push(`Étirement horizontal de facteur ${svaleur}`);
    }
}


  
if(k !== 1){

    if(k < 0){
        liste.push(`Symétrie orthogonale d'axe x`);
    }

    const kvaleur = Math.abs(k);

    if(kvaleur === 2 || kvaleur === 3){
        liste.push(`Étirement vertical de facteur ${kvaleur}`);
    }
    else if(valeur === 0.5 || valeur === 1/3){
        liste.push(`Compression verticale de facteur ${kvaleur}`);
    }
}


  if(v!==0){
    liste.push(
      v>0 ?
      `Translation verticale de ${v} unités vers le haut`
      :
      `Translation verticale de ${-v} unités vers le bas`
    );
  }

  bonneReponse = [...liste];

  /* Mélange */
  liste.sort(()=>Math.random()-0.5);

  afficherChoix(liste);
}


/* =========================   Affichage (ordre à choisir) ========================= */

function afficherChoix(liste){

  const zone = document.getElementById("zone-propositions");
  zone.innerHTML = "";

  liste.forEach((texte,i)=>{
    const div = document.createElement("div");
    div.className = "order-item";
    div.draggable = true;
    div.dataset.index = i;
    div.textContent = texte;
    zone.appendChild(div);
  });

  activerDragDrop();
}

function activerDragDrop(){

  const items = document.querySelectorAll(".order-item");
  let dragged = null;

  items.forEach(item=>{

    item.addEventListener("dragstart", ()=>{
      dragged = item;
      item.classList.add("dragging");
    });

    item.addEventListener("dragend", ()=>{
      item.classList.remove("dragging");
    });

    item.addEventListener("dragover", e=>{
      e.preventDefault();
    });

    item.addEventListener("drop", e=>{
      e.preventDefault();
      if(dragged !== item){
        const parent = item.parentNode;
        const children = Array.from(parent.children);
        const draggedIndex = children.indexOf(dragged);
        const targetIndex = children.indexOf(item);

        if(draggedIndex < targetIndex)
          parent.insertBefore(dragged, item.nextSibling);
        else
          parent.insertBefore(dragged, item);
      }
    });
  });
}


/* ========================= Vérification ========================= */

function verifier(){

  const items = document.querySelectorAll(".order-item");

  items.forEach(i=>i.classList.remove("correct","wrong"));

  let correct = true;

  items.forEach((item,i)=>{
    if(item.textContent === bonneReponse[i])
      item.classList.add("correct");
    else{
      item.classList.add("wrong");
      correct = false;
    }
  });
}



/* ========================= Solution ========================= */

function corriger(){

  const zone = document.getElementById("zone-propositions");
  zone.innerHTML = "";

  bonneReponse.forEach(t=>{
    const div = document.createElement("div");
    div.className = "order-item correct";
    div.textContent = t;
    zone.appendChild(div);
  });
}



/* ======================== Génération initiale ========================= */

genererEquation();
</script>

   
  <!-- Protection clique droit (commun à tout le site) -->
  <script src="../../../js/protection.js"></script>
  
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>

  <p>De quelle fonction s'agit-il ? </p>

  <!-- GRAPHIQUE -->
<div id="graph-container"
     style="position:relative; display:flex; justify-content:center; margin-bottom:20px;">
  <svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>
</div>


<div id="qcm" class="qcm-grid qcm-8"></div>

<div class="center-button">
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>



  <p id="feedback" class="feedback"></p>

  <div class="exo-links">
    <a href="../../4GT_fonctions.html">Retour au menu</a>
  </div>
</div>

<script>
/* ====================== PARAMETRES REPERE ====================== */
const svg = document.getElementById("graph");
const width = 400, height = 400;
const unit = 40;
const xmin = -5, xmax = 5;
const ymin = -5, ymax = 5;

/* ====================== VARIABLES ====================== */
let typeEquation = "";
let dernieresFonctions = [];
let nbEssaisFaux = 0;
let translationType = ""; // "horizontale" ou "verticale"
let h = 0;
let v = 0;
let typeTransformation = "";
let k = 1;
  
/* ====================== OUTILS ====================== */
function xToPx(x){ return width/2 + x*unit; }
function yToPx(y){ return height/2 - y*unit; }

  
/* ====================== REPERE ====================== */
function dessinerRepere(){
  svg.innerHTML="";

  for(let x=xmin;x<=xmax;x++){
    svg.innerHTML+=`<line x1="${xToPx(x)}" y1="0" x2="${xToPx(x)}" y2="${height}" stroke="#ddd"/>`;
  }
  for(let y=ymin;y<=ymax;y++){
    svg.innerHTML+=`<line x1="0" y1="${yToPx(y)}" x2="${width}" y2="${yToPx(y)}" stroke="#ddd"/>`;
  }

  svg.innerHTML+=`
    <line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="black" stroke-width="2"/>
    <line x1="${width/2}" y1="0" x2="${width/2}" y2="${height}" stroke="black" stroke-width="2"/>
  `;

  for(let x=xmin;x<=xmax;x++) if(x!==0)
    svg.innerHTML+=`<text x="${xToPx(x)+2}" y="${height/2+14}" font-size="12">${x}</text>`;

  for(let y=ymin;y<=ymax;y++) if(y!==0)
    svg.innerHTML+=`<text x="${width/2+6}" y="${yToPx(y)+4}" font-size="12">${y}</text>`;
}

function tracerCourbe(fonction) {
  let path = "";
  let first = true;

  for (let x = xmin; x <= xmax; x += 0.005) {
    let y = fonction(x);

if (
  !isFinite(y) ||
  y > ymax || y < ymin
) {
  first = true;
  continue;
}


    const px = xToPx(x);
    const py = yToPx(y);

    if (first) {
      path += `M ${px} ${py}`;
      first = false;
    } else {
      path += ` L ${px} ${py}`;
    }
  }

  svg.innerHTML += `
    <path d="${path}" fill="none"
          stroke="var(--peps)"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"/>
  `;
}

function tirerTypeTransformation() {
  const r = Math.random();

  if (r < 0.5) return "deformation";      // 50%
  if (r < 0.75) return "translation_v";   // 25%
  return "translation_h";                 // 25%
}

  function deformationVerticale(f, k) {
  return x => k * f(x);
}

function translationVerticale(f, k) {
  return x => f(x) + k;
}

function translationHorizontale(f, k) {
  return x => f(x + k);
}


function tirerFonctionSansABA() {
  const toutes = ["carr√©e", "cube", "valabs", "racine", "cubique", "inverse"];

  // On exclut STRICTEMENT les deux derni√®res fonctions
  const candidates = toutes.filter(f => !dernieresFonctions.includes(f));

  // S√©curit√© : si jamais on arrive √† moins de 1 (th√©oriquement impossible ici)
  if (candidates.length === 0) {
    console.warn("Reset historique fonctions");
    dernieresFonctions = [];
    return tirerFonctionSansABA();
  }

  const choix = candidates[Math.floor(Math.random() * candidates.length)];

  // Mise √† jour de l'historique
  dernieresFonctions.push(choix);
  if (dernieresFonctions.length > 2) {
    dernieresFonctions.shift(); // on garde seulement les 2 derni√®res
  }

  return choix;
}

function tirerTranslation() {
  const valeurs = [-3, -2, -1, 1, 2, 3];

  translationType = Math.random() < 0.5 ? "horizontale" : "verticale";

  if (translationType === "horizontale") {
    h = valeurs[Math.floor(Math.random() * valeurs.length)];
    v = 0;
  } else {
    v = valeurs[Math.floor(Math.random() * valeurs.length)];
    h = 0;
  }
}


function tirerHV() {
const valeurs = [-3, -2, -1, 1, 2, 3];
h = valeurs[Math.floor(Math.random() * valeurs.length)];
do {
v = valeurs[Math.floor(Math.random() * valeurs.length)];
} while (v === h || v === -h);
}

  
function fonctionTranslatee(f) {
  return function (x) {
    return f(x - h) + v;
  };
}
  
  function tracerAsymptotesInverse(h, v) {
  // asymptote verticale x = h
  svg.innerHTML += `
    <line x1="${xToPx(h)}" y1="0"
          x2="${xToPx(h)}" y2="${height}"
          stroke="var(--peps)"
          stroke-width="2.5"
          stroke-dasharray="4,4"/>
  `;

  // asymptote horizontale y = v
  svg.innerHTML += `
    <line x1="0" y1="${yToPx(v)}"
          x2="${width}" y2="${yToPx(v)}"
          stroke="var(--peps)"
          stroke-width="2.5"
          stroke-dasharray="4,4"/>
  `;
}

  function genererQCMTransformation(base, k) {
  const ak = Math.abs(k);

  const propositions = [
    { label: `${k}${base}`, correct: false },      // k¬∑f(x)
    { label: `${base} + ${k}`, correct: false },   // f(x)+k
    { label: `${base.replace("x", "x+" + k)}`, correct: false },
  ];

  return propositions;
}

  
  function genererQCMDeformationCarree(k) {
  const ak = Math.abs(k);

  const propositions = [
    { label: `${k}x^2`, correct: false },
    { label: `x^2 + ${k}`, correct: false },
    { label: `(x + ${k})^2`, correct: false },
    { label: `(x - ${k})^2`, correct: false }
  ];

  if (k !== 1) {
    propositions.find(p => p.label === `${k}x^2`).correct = true;
  }

  return melanger(propositions);
}



  function genererQCMDeformationValAbs(k) {
  const propositions = [
    { label: `${k}|x|`, correct: true },
    { label: `|x| + ${k}`, correct: false },
    { label: `|x + ${k}|`, correct: false },
    { label: `|x - ${k}|`, correct: false }
  ];

  return melanger(propositions);
}


  function genererQCMDeformationCube(k) {
  const propositions = [
    { label: `${k}x^3`, correct: true },
    { label: `x^3 + ${k}`, correct: false },
    { label: `(x + ${k})^3`, correct: false },
    { label: `(x - ${k})^3`, correct: false }
  ];

  return melanger(propositions);
}

function genererQCMDeformationRacine(k) {
  const propositions = [
    { label: `${k}\\sqrt{x}`, correct: true },
    { label: `\\sqrt{x} + ${k}`, correct: false },
    { label: `\\sqrt{x + ${k}}`, correct: false },
    { label: `\\sqrt{x - ${k}}`, correct: false }
  ];

  return melanger(propositions);
}


  function genererQCMDeformationCubique(k) {
  const propositions = [
    { label: `${k}\\sqrt[3]{x}`, correct: true },
    { label: `\\sqrt[3]{x} + ${k}`, correct: false },
    { label: `\\sqrt[3]{x + ${k}}`, correct: false },
    { label: `\\sqrt[3]{x - ${k}}`, correct: false }
  ];

  return melanger(propositions);
}


  function genererQCMDeformationInverse(k) {
  const propositions = [
    { label: `\\frac{${k}}{x}`, correct: true },
    { label: `\\frac{1}{x} + ${k}`, correct: false },
    { label: `\\frac{1}{x + ${k}}`, correct: false },
    { label: `\\frac{1}{x - ${k}}`, correct: false }
  ];

  return melanger(propositions);
}


  function appliquerTransformation(f) {
  if (typeTransformation === "deformation") {
    return deformationVerticale(f, k);
  }
  if (typeTransformation === "translation_v") {
    return translationVerticale(f, k);
  }
  return translationHorizontale(f, k);
}
  
  function melanger(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}




  
  function genererQCMValAbs(h, v) {
const ah = Math.abs(h);
const av = Math.abs(v);


const propositions = [
// Groupe A
{ label: `|x - ${ah}| + ${av}`, correct: false },
{ label: `|x - ${ah}| - ${av}`, correct: false },
{ label: `|x + ${ah}| + ${av}`, correct: false },
{ label: `|x + ${ah}| - ${av}`, correct: false },


// Groupe B
{ label: `|x - ${av}| + ${ah}`, correct: false },
{ label: `|x - ${av}| - ${ah}`, correct: false },
{ label: `|x + ${av}| + ${ah}`, correct: false },
{ label: `|x + ${av}| - ${ah}`, correct: false }
];


const bonne =
`|x ${h > 0 ? "- " + ah : "+ " + ah}| ` +
`${v > 0 ? "+ " + av : "- " + av}`;


propositions.find(p => p.label === bonne).correct = true;
return melanger(propositions);
}



  
function genererQCMRacine(h, v) {
const ah = Math.abs(h);
const av = Math.abs(v);


const propositions = [
// Groupe A
{ label: `\\sqrt{x - ${ah}} + ${av}`, correct: false },
{ label: `\\sqrt{x - ${ah}} - ${av}`, correct: false },
{ label: `\\sqrt{x + ${ah}} + ${av}`, correct: false },
{ label: `\\sqrt{x + ${ah}} - ${av}`, correct: false },


// Groupe B
{ label: `\\sqrt{x - ${av}} + ${ah}`, correct: false },
{ label: `\\sqrt{x - ${av}} - ${ah}`, correct: false },
{ label: `\\sqrt{x + ${av}} + ${ah}`, correct: false },
{ label: `\\sqrt{x + ${av}} - ${ah}`, correct: false }
];


const bonne =
`\\sqrt{x ${h > 0 ? "- " + ah : "+ " + ah}} ` +
`${v > 0 ? "+ " + av : "- " + av}`;


propositions.find(p => p.label === bonne).correct = true;
return melanger(propositions);
}

  function genererQCMCube(h, v) {
const ah = Math.abs(h);
const av = Math.abs(v);


const propositions = [
// Groupe A
{ label: `(x - ${ah})^3 + ${av}`, correct: false },
{ label: `(x - ${ah})^3 - ${av}`, correct: false },
{ label: `(x + ${ah})^3 + ${av}`, correct: false },
{ label: `(x + ${ah})^3 - ${av}`, correct: false },


// Groupe B
{ label: `(x - ${av})^3 + ${ah}`, correct: false },
{ label: `(x - ${av})^3 - ${ah}`, correct: false },
{ label: `(x + ${av})^3 + ${ah}`, correct: false },
{ label: `(x + ${av})^3 - ${ah}`, correct: false }
];


const bonne =
`(x ${h > 0 ? "- " + ah : "+ " + ah})^3 ` +
`${v > 0 ? "+ " + av : "- " + av}`;


propositions.find(p => p.label === bonne).correct = true;
return melanger(propositions);
}

 function genererQCMCubique(h, v) {
const ah = Math.abs(h);
const av = Math.abs(v);


const propositions = [
// Groupe A
{ label: `\\sqrt[3]{x - ${ah}} + ${av}`, correct: false },
{ label: `\\sqrt[3]{x - ${ah}} - ${av}`, correct: false },
{ label: `\\sqrt[3]{x + ${ah}} + ${av}`, correct: false },
{ label: `\\sqrt[3]{x + ${ah}} - ${av}`, correct: false },


// Groupe B
{ label: `\\sqrt[3]{x - ${av}} + ${ah}`, correct: false },
{ label: `\\sqrt[3]{x - ${av}} - ${ah}`, correct: false },
{ label: `\\sqrt[3]{x + ${av}} + ${ah}`, correct: false },
{ label: `\\sqrt[3]{x + ${av}} - ${ah}`, correct: false }
];


const bonne =
`\\sqrt[3]{x ${h > 0 ? "- " + ah : "+ " + ah}} ` +
`${v > 0 ? "+ " + av : "- " + av}`;


propositions.find(p => p.label === bonne).correct = true;
return melanger(propositions);
}

function genererQCMInverse(h, v) {
const ah = Math.abs(h);
const av = Math.abs(v);


const propositions = [
// Groupe A
{ label: `\\frac{1}{x - ${ah}} + ${av}`, correct: false },
{ label: `\\frac{1}{x - ${ah}} - ${av}`, correct: false },
{ label: `\\frac{1}{x + ${ah}} + ${av}`, correct: false },
{ label: `\\frac{1}{x + ${ah}} - ${av}`, correct: false },


// Groupe B
{ label: `\\frac{1}{x - ${av}} + ${ah}`, correct: false },
{ label: `\\frac{1}{x - ${av}} - ${ah}`, correct: false },
{ label: `\\frac{1}{x + ${av}} + ${ah}`, correct: false },
{ label: `\\frac{1}{x + ${av}} - ${ah}`, correct: false }
];


const bonne =
`\\frac{1}{x ${h > 0 ? "- " + ah : "+ " + ah}} ` +
`${v > 0 ? "+ " + av : "- " + av}`;


propositions.find(p => p.label === bonne).correct = true;
return melanger(propositions);
}

  
function afficherQCM(propositions) {
const qcm = document.getElementById("qcm");
qcm.innerHTML = "";


let nbErreurs = 0;
let bonneCarte = null; // üëà r√©f√©rence directe


propositions.forEach(p => {
const card = document.createElement("div");
card.className = "qcm-card";
card.innerHTML = `\\(${p.label}\\)`;


// On m√©morise la bonne carte
if (p.correct) {
bonneCarte = card;
}


card.onclick = () => {


// ---- BONNE R√âPONSE ----
if (p.correct) {
card.classList.add("correct");
document.querySelectorAll(".qcm-card")
.forEach(c => c.style.pointerEvents = "none");
return;
}


// ---- MAUVAISE R√âPONSE ----
card.classList.add("incorrect");
card.style.pointerEvents = "none";
nbErreurs++;


// ---- 2e ERREUR : on r√©v√®le la bonne ----
if (nbErreurs >= 2 && bonneCarte) {
bonneCarte.classList.add("correct");
document.querySelectorAll(".qcm-card")
.forEach(c => c.style.pointerEvents = "none");
}
};


qcm.appendChild(card);
});


MathJax.typesetPromise();
}
  
function genererQCM(type, h, v) {
  if (typeTransformation === "deformation") {
  switch (type) {
    case "carr√©e": return genererQCMDeformationCarree(k);
    case "valabs": return genererQCMDeformationValAbs(k);
    case "cube": return genererQCMDeformationCube(k);
    case "racine": return genererQCMDeformationRacine(k);
    case "cubique": return genererQCMDeformationCubique(k);
    case "inverse": return genererQCMDeformationInverse(k);
  }
}

  switch (type) {
    case "carr√©e":
      return genererQCMCarree(h, v);
    case "valabs":
      return genererQCMValAbs(h, v);
    case "racine":
      return genererQCMRacine(h, v);
    case "cube":
      return genererQCMCube(h, v);
    case "cubique":
      return genererQCMCubique(h, v);
    case "inverse":
      return genererQCMInverse(h, v);
    default:
      return [];
  }
}

  
/* ====================== GENERATION ====================== */
function genererEquation() {
  document.getElementById("feedback").innerHTML = "";

  const cards = document.querySelectorAll('.qcm-card');
  cards.forEach(card => {
    card.classList.remove('correct', 'incorrect');
    card.style.pointerEvents = "auto";
  });

  nbEssaisFaux = 0;

dessinerRepere();


typeEquation = tirerFonctionSansABA();
tirerHV();

typeTransformation = tirerTypeTransformation();
k = [-3, -2, -1, -0.5, 0.5, 2, 3][Math.floor(Math.random() * 7)];


let qcm; // ‚úÖ UNE SEULE D√âCLARATION


switch (typeEquation) {


case "carr√©e": {
  const f = x => x * x;
  tracerCourbe(appliquerTransformation(f));
  break;
}

case "cube": {
  const f = x => x * x * x;
  tracerCourbe(appliquerTransformation(f));
  break;
}

case "valabs": {
  const f = x => Math.abs(x);
  tracerCourbe(appliquerTransformation(f));
  break;
}


case "racine": {
  const f = x => Math.sqrt(x);

  const fTrans = appliquerTransformation(f);

  tracerCourbe(x => {
    if (
      (typeTransformation === "translation_h" && x + k < 0) ||
      (typeTransformation !== "translation_h" && x < 0)
    ) return NaN;

    return fTrans(x);
  });

  break;
}


case "cubique": {
  const f = x => Math.cbrt(x);
  tracerCourbe(appliquerTransformation(f));
  break;
}



case "inverse": {
  const f = x => 1 / x;

  if (typeTransformation === "deformation") {
    tracerCourbe(x => Math.abs(x) < 0.1 ? NaN : k / x);
  }

  else if (typeTransformation === "translation_v") {
    tracerAsymptotesInverse(0, k);
    tracerCourbe(x => Math.abs(x) < 0.1 ? NaN : 1 / x + k);
  }

  else {
    tracerAsymptotesInverse(-k, 0);
    tracerCourbe(x => Math.abs(x + k) < 0.1 ? NaN : 1 / (x + k));
  }

  break;
}



// ‚úÖ QCM g√©n√©r√© UNE FOIS, APR√àS le switch
qcm = genererQCM(typeEquation, h, v);
afficherQCM(qcm);
}


/* ====================== VERIFICATION ====================== */




// G√©n√©rer le premier exercice au chargement
window.onload = genererEquation;
</script>
   
  <!-- Protection clique droit (commun √† tout le site) -->
  <script src="../../../js/protection.js"></script>

</body>
</html>

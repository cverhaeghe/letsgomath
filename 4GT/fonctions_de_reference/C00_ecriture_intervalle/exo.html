<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>


  <!-- GRAPHIQUE -->
<div id="graph-container"
     style="position:relative; display:flex; justify-content:center; margin-bottom:20px;">
  <svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>
</div>

<div id="qcm" class="qcm-grid qcm-4"></div>

<div class="center-button">
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>




  <p id="feedback" class="feedback"></p>

  <div class="exo-links">
    <a href="../../4GT_fonctions.html">Retour au menu</a>
  </div>
</div>

<script>

// ========================= Param√®tres =========================

const svgNS = "http://www.w3.org/2000/svg";

let reponseCorrecte = "";
let exerciceVerrouille = false;

  
// ========================= Fonctions =========================
  
function ecrireIntervalle(a, sens) {
  if (sens === ">=") return `\\([${a};+‚àû[\\)`;
  if (sens === ">")  return `\\(]${a};+‚àû[\\)`;
  if (sens === "<=") return `\\(]-‚àû;${a}]\\)`;
  if (sens === "<")  return `\\(]-‚àû;${a}[\\)`;
}

  function ecrirePhraseDepuisRep(rep) {
  const a = parseInt(rep.replace(/[<>=]/g, ""));

  if (rep.startsWith(">=")) return `Tous les nombres sup√©rieurs ou √©gaux √† ${a}.`;
  if (rep.startsWith(">"))  return `Tous les nombres strictement sup√©rieurs √† ${a}.`;
  if (rep.startsWith("<=")) return `Tous les nombres inf√©rieurs ou √©gaux √† ${a}.`;
  return `Tous les nombres strictement inf√©rieures √† ${a}.`;
}

  
  function dessinerMiniDroite(svg, rep) {

  const y = 28;
  const x0 = 10;
  const x1 = 130;
  const centre = 70;
  const pas = 10;

  // ===== Axe =====
  const axe = document.createElementNS(svgNS, "line");
  axe.setAttribute("x1", x0);
  axe.setAttribute("x2", x1);
  axe.setAttribute("y1", y);
  axe.setAttribute("y2", y);
  axe.setAttribute("stroke", "black");
  svg.appendChild(axe);

  // ===== Graduations + chiffres =====
  for (let i = -5; i <= 5; i++) {

    const x = centre + i * pas;

    // Trait
    const tick = document.createElementNS(svgNS, "line");
    tick.setAttribute("x1", x);
    tick.setAttribute("x2", x);
    tick.setAttribute("y1", y - 4);
    tick.setAttribute("y2", y + 4);
    tick.setAttribute("stroke", "black");
    svg.appendChild(tick);

    // Nombre
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", x


  
// ========================= G√©n√©ration exercice =========================
  
function genererEquation() {

  exerciceVerrouille = false;

  // Tirage √©quilibr√© 1/3
  const r = Math.random();
  let typeEnonce;

  if (r < 1/3) typeEnonce = "droite";
  else if (r < 2/3) typeEnonce = "intervalle";
  else typeEnonce = "phrase";

  const a = Math.floor(Math.random()*9) - 2;
  const sensPossibles = [">=", "<=", ">", "<"];
  const sens = sensPossibles[Math.floor(Math.random()*4)];

  if (typeEnonce === "phrase") {
    afficherPhrase(a, sens);
  }
  else if (typeEnonce === "intervalle") {
    afficherIntervalle(a, sens);
  }
  else {
    afficherDroite(a, sens);
  }

// Choix d‚Äôun type diff√©rent pour le QCM
const types = ["intervalle", "phrase", "droite"];
const typesPossibles = types.filter(t => t !== typeEnonce);
const typeQCM = typesPossibles[Math.floor(Math.random()*typesPossibles.length)];

genererQCM(a, sens, typeEnonce, typeQCM);
  document.getElementById("feedback").textContent = "";
}


// ========================= ENONC√âS =========================
  
function afficherPhrase(a, sens) {
  effacerGraphique();

  let texte;

  if (sens === ">=") {
    texte = `Tous les nombres sup√©rieurs ou √©gaux √† ${a}.`;
  }
  else if (sens === ">") {
    texte = `Tous les nombres strictement sup√©rieurs √† ${a}.`;
  }
  else if (sens === "<=") {
    texte = `Tous les nombres inf√©rieurs ou √©gaux √† ${a}.`;
  }
  else {
    texte = `Tous les nombres strictement inf√©rieurs √† ${a}.`;
  }

  document.getElementById("graph-container").innerHTML =
    `<p style="font-size:20px">${texte}</p>`;

  reponseCorrecte = `${sens}${a}`;
}


function afficherIntervalle(a, sens) {
  effacerGraphique();
let intervalle;

if (sens === ">=") intervalle = `[${a} ; +‚àû[`;
if (sens === ">")  intervalle = `]${a} ; +‚àû[`;
if (sens === "<=") intervalle = `]-‚àû ; ${a}]`;
if (sens === "<")  intervalle = `]-‚àû ; ${a}[`;

  document.getElementById("graph-container").innerHTML =
    `<p style="font-size:22px">\\(${intervalle}\\)</p>`;

  MathJax.typeset();
  reponseCorrecte = `${sens}${a}`;
}

function afficherDroite(a, sens) {
  effacerGraphique();

  const svg = document.getElementById("graph");
  svg.setAttribute("height", 120);
  svg.setAttribute("viewBox", "0 0 400 120");
  svg.innerHTML = "";

  const y = 60;

  // Axe horizontal
  const axe = document.createElementNS(svgNS, "line");
  axe.setAttribute("x1", 50);
  axe.setAttribute("x2", 350);
  axe.setAttribute("y1", y);
  axe.setAttribute("y2", y);
  axe.setAttribute("stroke", "black");
  svg.appendChild(axe);

  // Graduations + nombres
  for (let i = -5; i <= 5; i++) {
    const x = 200 + i * 25;

    // Petit trait
    const tick = document.createElementNS(svgNS, "line");
    tick.setAttribute("x1", x);
    tick.setAttribute("x2", x);
    tick.setAttribute("y1", y - 5);
    tick.setAttribute("y2", y + 5);
    tick.setAttribute("stroke", "black");
    svg.appendChild(tick);

    // Nombre
    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", x);
    label.setAttribute("y", y + 25);
    label.setAttribute("text-anchor", "middle");
    label.setAttribute("font-size", "12");
    label.textContent = i;
    svg.appendChild(label);
  }

  const xA = 200 + a * 25;

  // Segment rouge
  const segment = document.createElementNS(svgNS, "line");
  segment.setAttribute("y1", y);
  segment.setAttribute("y2", y);
  segment.setAttribute("stroke", "red");
  segment.setAttribute("stroke-width", 4);

  if (sens === ">=" || sens === ">") {
    segment.setAttribute("x1", xA);
    segment.setAttribute("x2", 350);
  } else {
    segment.setAttribute("x1", 50);
    segment.setAttribute("x2", xA);
  }
  svg.appendChild(segment);

  // Rond ouvert / ferm√©
  const point = document.createElementNS(svgNS, "circle");
  point.setAttribute("cx", xA);
  point.setAttribute("cy", y);
  point.setAttribute("r", 5);

  if (sens === ">=" || sens === "<=") {
    point.setAttribute("fill", "red");   // ferm√©
  } else {
    point.setAttribute("fill", "white"); // ouvert
    point.setAttribute("stroke", "red");
    point.setAttribute("stroke-width", 2);
  }

  svg.appendChild(point);
  reponseCorrecte = `${sens}${a}`;

}


function effacerGraphique() {
  document.getElementById("graph-container").innerHTML =
    `<svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>`;
}

// ========================= QCM =========================
  
function genererQCM(a, sens, typeEnonce, typeQCM){
  const qcm = document.getElementById("qcm");
  qcm.innerHTML = "";

  const propositions = [];

  // ===== CAS 1 : ENONCE = INTERVALLE ‚Üí PAS D‚ÄôINTERVALLE DANS LE QCM =====
  if (typeEnonce === "intervalle") {

// Bonne r√©ponse
propositions.push({
  val: `${sens}${a}`,
  txt: ecrireIntervalle(a, sens)
});

// ‚ùå Pi√®ge 1 : m√™me borne mais crochet invers√©
let sensCrochetInverse;
if (sens === ">=") sensCrochetInverse = ">";
else if (sens === ">") sensCrochetInverse = ">=";
else if (sens === "<=") sensCrochetInverse = "<";
else sensCrochetInverse = "<=";

propositions.push({
  val: `${sensCrochetInverse}${a}`,
  txt: ecrireIntervalle(a, sensCrochetInverse)
});

// ‚ùå Pi√®ge 2 : mauvais c√¥t√© mais m√™me borne
const sensInverse = {">=":"<=", "<=":">=", ">":"<", "<":">"}[sens];
propositions.push({
  val: `${sensInverse}${a}`,
  txt: ecrireIntervalle(a, sensInverse)
});

// ‚ùå Pi√®ge 3 : mauvais c√¥t√© + crochet invers√© (toujours m√™me borne)
let sensDouble;
if (sens === ">=") sensDouble = "<";
else if (sens === ">") sensDouble = "<=";
else if (sens === "<=") sensDouble = ">";
else sensDouble = ">=";

propositions.push({
  val: `${sensDouble}${a}`,
  txt: ecrireIntervalle(a, sensDouble)
});
  }

  // ===== AUTRES CAS ‚Üí INTERVALLES DANS LE QCM =====
  else {

  // Bonne r√©ponse
  propositions.push({
    val: `${sens}${a}`,
    txt: ecrireIntervalle(a, sens)
  });

  // ‚ùå Crochet invers√© (m√™me borne)
  let sensCrochetInverse;
  if (sens === ">=") sensCrochetInverse = ">";
  else if (sens === ">") sensCrochetInverse = ">=";
  else if (sens === "<=") sensCrochetInverse = "<";
  else sensCrochetInverse = "<=";

  propositions.push({
    val: `${sensCrochetInverse}${a}`,
    txt: ecrireIntervalle(a, sensCrochetInverse)
  });

  // ‚ùå Mauvais c√¥t√© (m√™me borne)
  const sensInverse = {">=":"<=", "<=":">=", ">":"<", "<":">"}[sens];

  propositions.push({
    val: `${sensInverse}${a}`,
    txt: ecrireIntervalle(a, sensInverse)
  });

  // ‚ùå Mauvais c√¥t√© + crochet invers√© (m√™me borne)
  let sensDouble;
  if (sens === ">=") sensDouble = "<";
  else if (sens === ">") sensDouble = "<=";
  else if (sens === "<=") sensDouble = ">";
  else sensDouble = ">=";

  propositions.push({
    val: `${sensDouble}${a}`,
    txt: ecrireIntervalle(a, sensDouble)
  });

}

    // M√©lange
  melanger(propositions);

  // Affichage des cartes
  propositions.forEach(p => {
  const div = document.createElement("div");
  div.className = "qcm-card";

  // ===== QCM EN INTERVALLE =====
  if (typeQCM === "intervalle") {
    div.innerHTML = p.txt;
  }

  // ===== QCM EN PHRASE =====
  else if (typeQCM === "phrase") {
    div.textContent = ecrirePhraseDepuisRep(p.val);
  }

  // ===== QCM EN MINI-DROITE =====
  else {
    const mini = document.createElementNS(svgNS, "svg");
    mini.setAttribute("width", 140);
    mini.setAttribute("height", 60);
    mini.setAttribute("viewBox", "0 0 140 60");
    dessinerMiniDroite(mini, p.val);
    div.appendChild(mini);
  }

  div.onclick = () => verifier(p.val, div);
  qcm.appendChild(div);
});


  MathJax.typeset();

}

function melanger(tab) {
  for (let i = tab.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [tab[i], tab[j]] = [tab[j], tab[i]];
  }
}

// ========================= V√©rification =========================
  
function verifier(rep, element) {

  // Si exercice verrouill√© ‚Üí plus aucun clic
  if (exerciceVerrouille) return;

  // Normalisation (s√©curit√©)
  const r1 = String(rep).trim();
  const r2 = String(reponseCorrecte).trim();

  if (r1 === r2) {

    element.classList.remove("faux");
    element.classList.add("correct");
    // üîí verrouillage
    exerciceVerrouille = true;

    // D√©sactiver tous les boutons
    document.querySelectorAll(".qcm-card").forEach(c => {
      c.style.cursor = "default";
      c.style.pointerEvents = "none";
    });

  } else {

    element.classList.add("faux");
  }
}






// G√©n√©rer le premier exercice au chargement
window.onload = genererEquation;
</script>
   
  <!-- Protection clique droit (commun √† tout le site) -->
  <script src="../../../js/protection.js"></script>

</body>
</html>

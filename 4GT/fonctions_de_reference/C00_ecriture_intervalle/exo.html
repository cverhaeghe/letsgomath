<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>

  <p>Que signifie ceci ? </p>

  <!-- GRAPHIQUE -->
<div id="graph-container"
     style="position:relative; display:flex; justify-content:center; margin-bottom:20px;">
  <svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>
</div>

<div id="qcm" class="qcm-grid qcm-4">

<div class="center-button">
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>



  <p id="feedback" class="feedback"></p>

  <div class="exo-links">
    <a href="../../4GT_fonctions.html">Retour au menu</a>
  </div>
</div>

<script>

// ========================= Paramètres =========================

const svgNS = "http://www.w3.org/2000/svg";

let reponseCorrecte = "";
// ========================= Fonctions =========================
  
function ecrireIntervalle(a, sens) {
  if (sens === ">=") return `\\([${a};+∞[\\)`;
  if (sens === ">")  return `\\(]${a};+∞[\\)`;
  if (sens === "<=") return `\\(]-∞;${a}]\\)`;
  if (sens === "<")  return `\\(]-∞;${a}[\\)`;
}

  function dessinerMiniDroite(svg, rep) {
  const y = 30;
  const x0 = 10;
  const x1 = 130;

  // Axe
  const axe = document.createElementNS(svgNS, "line");
  axe.setAttribute("x1", x0);
  axe.setAttribute("x2", x1);
  axe.setAttribute("y1", y);
  axe.setAttribute("y2", y);
  axe.setAttribute("stroke", "black");
  svg.appendChild(axe);

  // Borne a
  const a = parseInt(rep.replace(/[<>=]/g, ""));
  const xA = 70 + a * 6;   // position simplifiée

  // Segment rouge
  const segment = document.createElementNS(svgNS, "line");
  segment.setAttribute("y1", y);
  segment.setAttribute("y2", y);
  segment.setAttribute("stroke", "red");
  segment.setAttribute("stroke-width", 3);

  if (rep.includes(">")) {
    segment.setAttribute("x1", xA);
    segment.setAttribute("x2", x1);
  } else {
    segment.setAttribute("x1", x0);
    segment.setAttribute("x2", xA);
  }
  svg.appendChild(segment);

  // Rond ouvert / fermé
  const point = document.createElementNS(svgNS, "circle");
  point.setAttribute("cx", xA);
  point.setAttribute("cy", y);
  point.setAttribute("r", 4);

  if (rep.includes("=")) {
    point.setAttribute("fill", "red");      // fermé
  } else {
    point.setAttribute("fill", "white");    // ouvert
    point.setAttribute("stroke", "red");
    point.setAttribute("stroke-width", 2);
  }

  svg.appendChild(point);
}

  
// ========================= Génération exercice =========================
  
function genererEquation() {
  const types = ["phrase", "intervalle", "droite"];
  const typeEnonce = types[Math.floor(Math.random()*3)];

  const a = Math.floor(Math.random()*9) - 2;   // -2 à 6
const sensPossibles = [">=", "<=", ">", "<"];
const sens = sensPossibles[Math.floor(Math.random()*4)];

  if (typeEnonce === "phrase") {
    afficherPhrase(a, sens);
  } else if (typeEnonce === "intervalle") {
    afficherIntervalle(a, sens);
  } else {
    afficherDroite(a, sens);
  }

genererQCM(a, sens, typeEnonce);
  document.getElementById("feedback").textContent = "";
}

// ========================= ENONCÉS =========================
  
function afficherPhrase(a, sens) {
  effacerGraphique();
  const texte = sens === ">=" ?
    `Tous les nombres supérieurs ou égaux à ${a}` :
    `Tous les nombres inférieurs ou égaux à ${a}`;

  document.getElementById("graph-container").innerHTML =
    `<p style="font-size:20px">${texte}</p>`;

  reponseCorrecte = `${sens}${a}`;
}

function afficherIntervalle(a, sens) {
  effacerGraphique();
let intervalle;

if (sens === ">=") intervalle = `[${a} ; +∞[`;
if (sens === ">")  intervalle = `]${a} ; +∞[`;
if (sens === "<=") intervalle = `]-∞ ; ${a}]`;
if (sens === "<")  intervalle = `]-∞ ; ${a}[`;

  document.getElementById("graph-container").innerHTML =
    `<p style="font-size:22px">\\(${intervalle}\\)</p>`;

  MathJax.typeset();
  reponseCorrecte = `${sens}${a}`;
}

function afficherDroite(a, sens) {
  const svg = document.getElementById("graph");
  svg.innerHTML = "";

  // Axe
  const axe = document.createElementNS(svgNS, "line");
  axe.setAttribute("x1", 50);
  axe.setAttribute("x2", 350);
  axe.setAttribute("y1", 65);
  axe.setAttribute("y2", 70);
  axe.setAttribute("stroke", "black");
  svg.appendChild(axe);

  // Graduations
  for (let i=-5; i<=5; i++) {
    const x = 200 + i*25;
    const tick = document.createElementNS(svgNS, "line");
    tick.setAttribute("x1", x);
    tick.setAttribute("x2", x);
    tick.setAttribute("y1", 65);
    tick.setAttribute("y2", 70);
    tick.setAttribute("stroke", "black");
    svg.appendChild(tick);

    const label = document.createElementNS(svgNS, "text");
    label.setAttribute("x", x);
    label.setAttribute("y", 95);
    label.setAttribute("text-anchor", "middle");
    label.textContent = i;
    svg.appendChild(label);
  }

  const xA = 200 + a*25;

// Segment coloré
const segment = document.createElementNS(svgNS, "line");
segment.setAttribute("y1", 65);
segment.setAttribute("y2", 70);
segment.setAttribute("stroke", "red");
segment.setAttribute("stroke-width", 4);

if (sens === ">=") {
  segment.setAttribute("x1", xA);
  segment.setAttribute("x2", 350);
} else {
  segment.setAttribute("x1", 50);
  segment.setAttribute("x2", xA);
}
svg.appendChild(segment);


// Point ouvert / fermé
const point = document.createElementNS(svgNS, "circle");
point.setAttribute("cx", xA);
point.setAttribute("cy", 70);
point.setAttribute("r", 5);

if (sens === ">=" || sens === "<=") {
  point.setAttribute("fill", "red");      // fermé
} else {
  point.setAttribute("fill", "white");    // ouvert
  point.setAttribute("stroke", "red");
  point.setAttribute("stroke-width", 2);
}

svg.appendChild(point);
}

function effacerGraphique() {
  document.getElementById("graph-container").innerHTML =
    `<svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>`;
}

// ========================= QCM =========================
  
function genererQCM(a, sens, typeEnonce) {
  const qcm = document.getElementById("qcm");
  qcm.innerHTML = "";

  const propositions = [];

  // ===== CAS 1 : ENONCE = INTERVALLE → PAS D’INTERVALLE DANS LE QCM =====
  if (typeEnonce === "intervalle") {

// Bonne réponse
propositions.push({
  val: `${sens}${a}`,
  txt: ecrireIntervalle(a, sens)
});

// ❌ Piège 1 : mauvais côté
const sensInverse = {">=":"<=", "<=":">=", ">":"<", "<":">"}[sens];
propositions.push({
  val: `${sensInverse}${a}`,
  txt: ecrireIntervalle(a, sensInverse)
});

// ❌ Piège 2 : mauvais ouvert / fermé
let sensOuverture;
if (sens === ">=") sensOuverture = ">";
else if (sens === ">") sensOuverture = ">=";
else if (sens === "<=") sensOuverture = "<";
else sensOuverture = "<=";

propositions.push({
  val: `${sensOuverture}${a}`,
  txt: ecrireIntervalle(a, sensOuverture)
});

// ❌ Piège 3 : mauvaise borne
propositions.push({
  val: `${sens}${a+1}`,
  txt: ecrireIntervalle(a+1, sens)
});


  }

  // ===== AUTRES CAS → INTERVALLES DANS LE QCM =====
  else {

    propositions.push({val:`>=${a}`, txt:`\\([${a};+∞[\\)`});
    propositions.push({val:`<=${a}`, txt:`\\(]-∞;${a}]\\)`});
    propositions.push({val:`>=${a+1}`, txt:`\\([${a+1};+∞[\\)`});
    propositions.push({val:`<=${a-1}`, txt:`\\(]-∞;${a-1}]\\)`});

  }

  melanger(propositions);

  propositions.forEach(p => {
    const div = document.createElement("div");
    div.className = "qcm-card";
    div.innerHTML = p.txt;
    div.onclick = () => verifier(p.val, div);
    qcm.appendChild(div);
  });

  MathJax.typeset();
}


function melanger(tab) {
  for (let i = tab.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [tab[i], tab[j]] = [tab[j], tab[i]];
  }
}

// ========================= Vérification =========================
  
function verifier(rep, element) {
  const cartes = document.querySelectorAll(".qcm-card");
  cartes.forEach(c => c.classList.remove("correct","faux"));

  if (rep === reponseCorrecte) {
    element.classList.add("correct");
    document.getElementById("feedback").textContent = "✔ Bonne réponse";
  } else {
    element.classList.add("faux");
    document.getElementById("feedback").textContent = "✘ Mauvaise réponse";
  }
}



// Générer le premier exercice au chargement
window.onload = genererEquation;
</script>
   
  <!-- Protection clique droit (commun à tout le site) -->
  <script src="../../../js/protection.js"></script>

</body>
</html>

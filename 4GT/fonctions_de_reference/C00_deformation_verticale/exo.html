<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>
  <p>De quelle fonction s'agit-il&nbsp;?</p>

  <div id="graph-container" style="display:flex; justify-content:center; margin-bottom:20px;">
    <svg id="graph" width="400" height="400"></svg>
  </div>

  <div id="qcm" class="qcm-grid qcm-4"></div>

  <div class="center-button">
    <button onclick="genererEquation()">Nouvel exercice</button>
  </div>
</div>

<script>
/* ================= REPÈRE ================= */
const svg = document.getElementById("graph");
const width = 400, height = 400;
const unit = 40;
const xmin = -5, xmax = 5;
const ymin = -5, ymax = 5;

function xToPx(x){ return width/2 + x*unit; }
function yToPx(y){ return height/2 - y*unit; }

function dessinerRepere(){
  svg.innerHTML = "";
  for(let x=xmin;x<=xmax;x++){
    svg.innerHTML += `<line x1="${xToPx(x)}" y1="0" x2="${xToPx(x)}" y2="${height}" stroke="#ddd"/>`;
  }
  for(let y=ymin;y<=ymax;y++){
    svg.innerHTML += `<line x1="0" y1="${yToPx(y)}" x2="${width}" y2="${yToPx(y)}" stroke="#ddd"/>`;
  }
  svg.innerHTML += `
    <line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="black" stroke-width="2"/>
    <line x1="${width/2}" y1="0" x2="${width/2}" y2="${height}" stroke="black" stroke-width="2"/>
  `;
}

/* ================= VARIABLES ================= */
let typeEquation = "";
let transformationType = "";
let k = 1;
let dernieresFonctions = [];

/* ================= TIRAGES ================= */
function tirerK(){
  const valeurs = [1/2,2,3];
  k = valeurs[Math.floor(Math.random()*valeurs.length)];
}

function tirerTransformationK(){
  const types = ["kf","plusk","moinsk","xplusk","xmoinsk"];
  transformationType = types[Math.floor(Math.random()*types.length)];
}

function tirerFonctionSansABA(){
  const toutes = ["carrée","valabs","racine","cube","cubique","inverse"];
  const possibles = toutes.filter(f=>!dernieresFonctions.includes(f));
  const choix = possibles[Math.floor(Math.random()*possibles.length)];
  dernieresFonctions.push(choix);
  if(dernieresFonctions.length>2) dernieresFonctions.shift();
  return choix;
}

/* ================= FONCTIONS ================= */
function fonctionDeBase(type){
  switch(type){
    case "carrée": return x=>x*x;
    case "valabs": return x=>Math.abs(x);
    case "racine": return x=>x>=0?Math.sqrt(x):NaN;
    case "cube": return x=>x*x*x;
    case "cubique": return x=>Math.cbrt(x);
    case "inverse": return x=>Math.abs(x)<0.1?NaN:1/x;
  }
}

function fonctionTransformee(f){
  switch(transformationType){
    case "kf": return x=>k*f(x);
    case "plusk": return x=>f(x)+k;
    case "moinsk": return x=>f(x)-k;
    case "xplusk": return x=>f(x+k);
    case "xmoinsk": return x=>f(x-k);
    default: return f;
  }
}

/* ================= TRACÉ ================= */
function tracerCourbe(f){
  let path="", first=true;
  for(let x=xmin;x<=xmax;x+=0.01){
    const y=f(x);
    if(!isFinite(y)||y<ymin||y>ymax){ first=true; continue; }
    const px=xToPx(x), py=yToPx(y);
    path += first?`M ${px} ${py}`:` L ${px} ${py}`;
    first=false;
  }
  svg.innerHTML += `<path d="${path}" fill="none" stroke="var(--peps)" stroke-width="3"/>`;
}

/* ================= QCM ================= */
function melanger(a){
  for(let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}



function genererQCMK(type){
  switch(type){
    case "carrée":
       return melanger([
    {label:`x^2+${k}`,correct:transformationType==="plusk"},
    {label:`x^2-${k}`,correct:transformationType==="moinsk"},
    {label:`(x+${k})^2`,correct:transformationType==="xplusk"},
    {label:`(x-${k})^2`,correct:transformationType==="xmoinsk"},
    {label:`\\dfrac{x^2}{${k}}`,correct:false},
    {label:`${k}x^2`,correct:transformationType==="kf"}
  ]);

    case "valabs":
      return melanger([
        {label:`|x|+${k}`,correct:transformationType==="plusk"},
        {label:`|x|-${k}`,correct:transformationType==="moinsk"},
        {label:`|x+${k}|`,correct:transformationType==="xplusk"},
        {label:`|x-${k}|`,correct:transformationType==="xmoinsk"},
        {label:`\\dfrac{|x|}{${k}}`,correct:false},
        {label:`${k}|x|`,correct:transformationType==="kf"}
      ]);

    case "racine":
      return melanger([
        {label:`\\sqrt{x}+${k}`,correct:transformationType==="plusk"},
        {label:`\\sqrt{x}-${k}`,correct:transformationType==="moinsk"},
        {label:`\\sqrt{x+${k}}`,correct:transformationType==="xplusk"},
        {label:`\\sqrt{x-${k}}`,correct:transformationType==="xmoinsk"},
        {label:`\\dfrac{\\sqrt{x}}{${k}}`,correct:false},
        {label:`${k}\\sqrt{x}`,correct:transformationType==="kf"}
      ]);

    case "cube":
      return melanger([
        {label:`x^3+${k}`,correct:transformationType==="plusk"},
        {label:`x^3-${k}`,correct:transformationType==="moinsk"},
        {label:`(x+${k})^3`,correct:transformationType==="xplusk"},
        {label:`(x-${k})^3`,correct:transformationType==="xmoinsk"},
        {label:`\\dfrac{x^3}{${k}}`,correct:false},
        {label:`${k}x^3`,correct:transformationType==="kf"}
      ]);

    case "cubique":
      return melanger([
        {label:`\\sqrt[3]{x}+${k}`,correct:transformationType==="plusk"},
        {label:`\\sqrt[3]{x}-${k}`,correct:transformationType==="moinsk"},
        {label:`\\sqrt[3]{x+${k}}`,correct:transformationType==="xplusk"},
        {label:`\\sqrt[3]{x-${k}}`,correct:transformationType==="xmoinsk"},
        {label:`\\dfrac{\\sqrt[3]{x}}{${k}}`,correct:false},
        {label:`${k}\\sqrt[3]{x}`,correct:transformationType==="kf"}
      ]);

    case "inverse":
      return melanger([
        {label:`\\dfrac{1}{x}+${k}`,correct:transformationType==="plusk"},
        {label:`\\dfrac{1}{x}-${k}`,correct:transformationType==="moinsk"},
        {label:`\\dfrac{1}{x+${k}}`,correct:transformationType==="xplusk"},
        {label:`\\dfrac{1}{x-${k}}`,correct:transformationType==="xmoinsk"},
        {label:`\\dfrac{1}{${k}x}`,correct:false},
        {label:`\\dfrac{${k}}{x}`,correct:transformationType==="kf"}
      ]);

    default:
      return [];
  }
}



function afficherQCM(props){
  const qcm=document.getElementById("qcm");
  qcm.innerHTML="";
  let bonne=null, erreurs=0;

  props.forEach(p=>{
    const c=document.createElement("div");
    c.className="qcm-card";
    c.innerHTML=`\\(${p.label}\\)`;
    if(p.correct) bonne=c;
    c.onclick=()=>{
      if(p.correct){
        c.classList.add("correct");
      }else{
        c.classList.add("incorrect");
        erreurs++;
        if(erreurs>=2&&bonne) bonne.classList.add("correct");
      }
      document.querySelectorAll(".qcm-card").forEach(x=>x.style.pointerEvents="none");
    };
    qcm.appendChild(c);
  });
  MathJax.typesetPromise();
}

/* ================= GÉNÉRATION ================= */
function genererEquation(){
  dessinerRepere();
  tirerK();
  tirerTransformationK();
  typeEquation = tirerFonctionSansABA();

  const fBase = fonctionDeBase(typeEquation);
  const fFinale = fonctionTransformee(fBase);
  tracerCourbe(fFinale);

  afficherQCM(genererQCMK(typeEquation));
}

window.onload = genererEquation;
</script>

<script src="../../../js/protection.js"></script>
</body>
</html>

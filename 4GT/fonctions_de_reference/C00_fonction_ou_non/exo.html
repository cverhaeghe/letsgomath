<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<!-- CSS -->
<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<!-- Bootstrap -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- MathJax v3 -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>

<p>La courbe repr√©sente-t-elle une fonction ?</p>
  
  <!-- GRAPHIQUE -->
<div id="graph-container"
     style="position:relative; display:flex; justify-content:center; margin-bottom:20px;">
  <svg id="graph" width="400" height="400" viewBox="0 0 400 400"></svg>
</div>


  <!-- QCM -->
<div id="qcm" class="qcm-grid qcm-2">
  <div class="qcm-card" onclick="verifier('fonction', this)">Fonction</div>
  <div class="qcm-card" onclick="verifier('pasfonction', this)">Pas une fonction</div>
</div>


<div class="center-button">
  <button onclick="genererEquation()">Nouvel exercice</button>
</div>



  <p id="feedback" class="feedback"></p>

  <div class="exo-links">
    <a href="../../4GT_fonctions.html">Retour au menu</a>
  </div>
</div>

<script>
/* ====================== PARAMETRES REPERE ====================== */
const svg = document.getElementById("graph");
const width = 400, height = 400;
const unit = 40;
const xmin = -5, xmax = 5;
const ymin = -5, ymax = 5;
const PAS = 0.05;

const TOUS_LES_EXERCICES = [
{ nom: "parabole", type: "fonction" },
{ nom: "fonctionBizarre", type: "fonction" },
{ nom: "montagne", type: "fonction" },


{ nom: "cercle", type: "pasfonction" },
{ nom: "ellipse", type: "pasfonction" },
{ nom: "paraboleCouchee", type: "pasfonction" },
{ nom: "segmentsCroises", type: "pasfonction" },
{ nom: "parabole_point_en_plus", type: "pasfonction" },
{ nom: "presqueFonction_segmentVertical", type: "pasfonction" },
{ nom: "presqueFonction_morceaux", type: "pasfonction" }
];
  
/* ====================== VARIABLES ====================== */
let typeEquation = "";
let dernieresFonctions = [];
let xProbleme = null;
let intersectionMode = null;
let paquetExercices = [];
  
/* ====================== OUTILS ====================== */
function xToPx(x){ return width/2 + x*unit; }
function yToPx(y){ return height/2 - y*unit; }

  
/* ====================== REPERE ====================== */
function dessinerRepere(){
  svg.innerHTML="";

  for(let x=xmin;x<=xmax;x++){
    svg.innerHTML+=`<line x1="${xToPx(x)}" y1="0" x2="${xToPx(x)}" y2="${height}" stroke="#ddd"/>`;
  }
  for(let y=ymin;y<=ymax;y++){
    svg.innerHTML+=`<line x1="0" y1="${yToPx(y)}" x2="${width}" y2="${yToPx(y)}" stroke="#ddd"/>`;
  }

  svg.innerHTML+=`
    <line x1="0" y1="${height/2}" x2="${width}" y2="${height/2}" stroke="black" stroke-width="2"/>
    <line x1="${width/2}" y1="0" x2="${width/2}" y2="${height}" stroke="black" stroke-width="2"/>
  `;

  for(let x=xmin;x<=xmax;x++) if(x!==0)
    svg.innerHTML+=`<text x="${xToPx(x)+2}" y="${height/2+14}" font-size="12">${x}</text>`;

  for(let y=ymin;y<=ymax;y++) if(y!==0)
    svg.innerHTML+=`<text x="${width/2+6}" y="${yToPx(y)+4}" font-size="12">${y}</text>`;
}

function tracerCourbe(fonction) {
  let path = "";
  let first = true;

  for (let x = xmin; x <= xmax; x += 0.005) {
    let y = fonction(x);

if (
  !isFinite(y) ||
  y > ymax || y < ymin
) {
  first = true;
  continue;
}


    const px = xToPx(x);
    const py = yToPx(y);

    if (first) {
      path += `M ${px} ${py}`;
      first = false;
    } else {
      path += ` L ${px} ${py}`;
    }
  }

  svg.innerHTML += `
    <path d="${path}" fill="none"
          stroke="var(--peps)"
          stroke-width="3"
          stroke-linecap="round"
          stroke-linejoin="round"/>
  `;
}


function melanger(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

  
function tirerFonctionSansABA() {
  const toutes = ["carr√©e", "cube", "valabs", "racine", "cubique", "inverse"];

  // On exclut les deux derni√®res fonctions
  let candidates = toutes.filter(f => !dernieresFonctions.includes(f));

  // S√©curit√© (au cas tr√®s improbable o√π il n'y aurait plus de candidates)
  if (candidates.length === 0) {
    candidates = toutes;
  }

  const choix = candidates[Math.floor(Math.random() * candidates.length)];

  // Mise √† jour de l'historique
  dernieresFonctions.push(choix);
  if (dernieresFonctions.length > 2) {
    dernieresFonctions.shift(); // on garde seulement les 2 derni√®res
  }

  return choix;
}

function tirerCourbe() {
  // Si le paquet est vide ‚Üí on le recr√©e et on le m√©lange
  if (paquetExercices.length === 0) {
    paquetExercices = [...TOUS_LES_EXERCICES];
    melanger(paquetExercices);
  }

  // On prend le premier exercice du paquet
  return paquetExercices.shift();
}

  

function animerDroiteVerticale(xStop = null) {
const old = document.getElementById("droite-verticale");
if (old) old.remove();


const ligne = document.createElementNS("http://www.w3.org/2000/svg", "line");
ligne.setAttribute("id", "droite-verticale");
ligne.setAttribute("y1", 0);
ligne.setAttribute("y2", height);
ligne.setAttribute("stroke", "blue");
ligne.setAttribute("stroke-width", "3");
ligne.setAttribute("stroke-dasharray", "6,4");


svg.appendChild(ligne);


let x = xmin;
let messageAffiche = false;


const animation = setInterval(() => {
ligne.setAttribute("x1", xToPx(x));
ligne.setAttribute("x2", xToPx(x));


/* üî¥ CAS PAS UNE FONCTION : arr√™t sur xProbleme */
if (xStop !== null && x + PAS / 2 >= xStop) {
ligne.setAttribute("x1", xToPx(xStop));
ligne.setAttribute("x2", xToPx(xStop));


clearInterval(animation);
afficherPointsIntersection(xStop);
afficherConclusion();
return;
}


/* üîµ CAS FONCTION : boucle infinie */
if (x > xmax) {
if (!messageAffiche) {
afficherConclusion();
messageAffiche = true;
}
x = xmin; // üîÅ retour √† gauche
}


x += PAS;
}, 20);
}

function afficherPointsIntersection(x) {
  if (!intersectionMode) return;

  // üîµ Cas : deux points (sym√©triques)
  if (intersectionMode.type === "deuxPoints") {
    const y = intersectionMode.f(x);
    if (isFinite(y)) {
      dessinerPointBleu(x, y);
      dessinerPointBleu(x, -y);
    }
    return;
  }

  // üîµ Cas : deux valeurs explicites
  if (intersectionMode.type === "deuxValeurs") {
    const ys = intersectionMode.values(x);
    ys.forEach(y => dessinerPointBleu(x, y));
    return;
  }

  // üîµ Cas : infinit√© de points
  if (intersectionMode.type === "infini") {
    dessinerSegmentVerticalBleu(
      x,
      intersectionMode.yMin,
      intersectionMode.yMax
    );
    return;
  }
}
  
function dessinerPoint(x, y) {
  svg.innerHTML += `
    <circle cx="${xToPx(x)}"
            cy="${yToPx(y)}"
            r="5"
            fill="var(--peps)"
            stroke="var(--peps)"
            stroke-width="0"/>
  `;
}


  function tracerParametrique(fx, fy, tMin, tMax, step = 0.01) {
let path = "";
let first = true;


for (let t = tMin; t <= tMax; t += step) {
const x = fx(t);
const y = fy(t);


if (!isFinite(x) || !isFinite(y)) continue;


const px = xToPx(x);
const py = yToPx(y);


if (first) {
path += `M ${px} ${py}`;
first = false;
} else {
path += ` L ${px} ${py}`;
}
}


svg.innerHTML += `
<path d="${path}"
fill="none"
stroke="var(--peps)"
stroke-width="3"
stroke-linecap="round"
stroke-linejoin="round"/>
`;
}


  function dessinerPointBleu(x, y) {
svg.innerHTML += `
<circle cx="${xToPx(x)}"
cy="${yToPx(y)}"
r="6"
fill="blue"
stroke="blue"
stroke-width="0"/>
`;
}


function dessinerSegmentVerticalBleu(x, yMin, yMax) {
const segment = document.createElementNS("http://www.w3.org/2000/svg", "line");


segment.setAttribute("x1", xToPx(x));
segment.setAttribute("x2", xToPx(x));
segment.setAttribute("y1", yToPx(yMin));
segment.setAttribute("y2", yToPx(yMax));


segment.setAttribute("stroke", "blue"); // m√™me bleu que la verticale
segment.setAttribute("stroke-width", "6"); // PLUS √âPAIS que l‚Äôorange
segment.setAttribute("stroke-linecap", "round");


// üîù GARANTI AU PREMIER PLAN
svg.appendChild(segment);
}


  function afficherConclusion() {
const feedback = document.getElementById("feedback");


if (typeEquation === "pasfonction") {
feedback.innerHTML =
"Il ne s‚Äôagit pas d‚Äôune fonction quand un x ou plusieurs x ont plus d'une image (y).";
} else {
feedback.innerHTML =
"Il s‚Äôagit d‚Äôune fonction car chaque x a maximum une image (y).";
}
}

  
/* ====================== GENERATION ====================== */
function genererEquation() {
  intersectionMode = null;
  xProbleme = null;

  document.getElementById("feedback").innerHTML = "";

  const cards = document.querySelectorAll('.qcm-card');
  cards.forEach(card => {
    card.classList.remove('correct', 'incorrect');
    card.style.pointerEvents = "auto";
  });

  
  
const courbe = tirerCourbe();
typeEquation = courbe.type;
dessinerRepere();

  switch (courbe.nom) {
            
case "parabole":
  tracerCourbe(x => 0.5 * x * x - 1);
  xProbleme = null;
  intersectionMode = null;
  break;

case "fonctionBizarre":
  tracerCourbe(x => Math.sin(x) + x / 3);
  xProbleme = null;
  intersectionMode = null;
  break;

case "montagne":
  tracerCourbe(x => {
    if (x < -2) return -1;
    if (x < 0) return x + 1;
    if (x < 2) return -x + 1;
    return 0.5;
  });
  xProbleme = null;
intersectionMode = null;    
  break;

case "cercle":
  tracerParametrique(
    t => 2 * Math.cos(t),
    t => 2 * Math.sin(t),
    0,
    2 * Math.PI
  );
  xProbleme = -1;
  intersectionMode = {
    type: "deuxPoints",
    f: x => Math.sqrt(4 - x * x)
  };
  break;   

case "ellipse":
tracerParametrique(
t => 3 * Math.cos(t),
t => Math.sqrt(3) * Math.sin(t),
0,
2 * Math.PI
);
xProbleme = -2; // ou -2 si tu pr√©f√®res p√©dagogiquement
intersectionMode = {
type: "deuxPoints",
f: x => Math.sqrt(3 * (1 - x * x / 9))
};
break;

case "paraboleCouchee":
  tracerParametrique(
    t => t * t - 2,
    t => t,
    -3,
    3
  );
  xProbleme = -1;
  intersectionMode = {
    type: "deuxPoints",
    f: x => Math.sqrt(x + 2)
  };
  break;

case "segmentsCroises":
  tracerCourbe(x => x);
  tracerCourbe(x => -x);
  xProbleme = -3;
  intersectionMode = {
    type: "deuxValeurs",
    values: x => [x, -x]
  };
  break;

case "parabole_point_en_plus":
  // Parabole y = x¬≤ - 1
  tracerCourbe(x => x * x - 1);

  // Point suppl√©mentaire (qui casse la fonction)
  dessinerPoint(1, 2); // par exemple

  xProbleme = 1;
  intersectionMode = {
    type: "deuxValeurs",
    values: x => [
      x * x - 1, // valeur de la parabole
      2          // valeur du point ajout√©
    ]
  };
  break;
      

case "presqueFonction_segmentVertical":
tracerCourbe(x => {
if (x < -1) return  x + 1;
if (x < 2) return -x + 1;
return 0;
});
xProbleme = 2;
typeEquation = "pasfonction";
intersectionMode = {
type: "infini",
yMin: -1,
yMax: 0
};
break;

 case "presqueFonction_morceaux":
  tracerCourbe(x => {
    if (x < 1) return x;
    if (x > 1) return 2 - x;
    return NaN; // on √©vite le point central
  });

  // Deux points pour x = 1
dessinerPoint(1, -1);
xProbleme = 1;
typeEquation = "pasfonction";
intersectionMode = {
  type: "deuxValeurs",
  values: x => [1, -1]
};
  break;
      
  }
}


/* ====================== VERIFICATION ====================== */
function verifier(reponseEleve, element) {
  const cards = document.querySelectorAll('.qcm-card');

  // D√©sactiver les clics
  cards.forEach(card => card.style.pointerEvents = "none");

  if (reponseEleve === typeEquation) {
    // ‚úÖ Bonne r√©ponse de l'√©l√®ve
    element.classList.add('correct');
  } else {
    // ‚ùå Mauvaise r√©ponse de l'√©l√®ve
    element.classList.add('incorrect');

    // ‚úÖ On met en vert la bonne r√©ponse
    cards.forEach(card => {
      if (
        (card.textContent.includes("Fonction") && typeEquation === "fonction") ||
        (card.textContent.includes("Pas une fonction") && typeEquation === "pasfonction")
      ) {
        card.classList.add('correct');
      }
    });
  }

  // Lancer le test de la droite verticale
  if (typeEquation === "pasfonction") {
    animerDroiteVerticale(xProbleme);
  } else {
    animerDroiteVerticale();
  }
}

// G√©n√©rer le premier exercice au chargement
window.onload = genererEquation;
</script>
   
  <!-- Protection clique droit (commun √† tout le site) -->
  <script src="../../../js/protection.js"></script>

</body>
</html>

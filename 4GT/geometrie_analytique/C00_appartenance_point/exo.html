<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Let's go Math !</title>

<link rel="stylesheet" href="../../../style.css">
<link rel="stylesheet" href="../../../exercices.css">

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>

<nav class="lgm-navbar">
  <ul class="nav-liste">
    <li><a href="../../../index.html">Accueil</a></li>
    <li><a href="../../../index.html#dia2">4GT</a></li>
    <li><a href="../../../index.html#dia3">5GT 6h</a></li>
    <li><a href="../../../index.html#dia4">6GT 6h</a></li>
  </ul>
</nav>

<div class="exo-container">
  <h1>Exercice</h1>

  <div class="equation-box" id="enonce"></div>

  <input type="text" id="reponse" placeholder="Oui ou non ?">

  <button onclick="verifier()">V√©rifier</button>
  <button onclick="corriger()">Correction</button>
  <button onclick="generer()">Nouvel exercice</button>

  <p id="feedback" class="feedback"></p>

  <div class="exo-links">
    <a href="../../4GT_geo_analytique.html">Retour au menu</a>
  </div>
</div>

<script>
/* =====================================================
   OUTILS FRACTIONS & MATH
===================================================== */
function pgcd(a,b){
  a=Math.abs(a); b=Math.abs(b);
  while(b!==0){ let t=b; b=a%b; a=t; }
  return a;
}

function ppcm(a, b) {
  return Math.abs(a * b) / pgcd(a, b);
}

function ppcmListe(dens) {
  return dens.reduce((acc, d) => ppcm(acc, d), 1);
}
  
function fractionIrreductible(num, den){
  if(den<0){ num=-num; den=-den; }
  const p=pgcd(num,den);
  return {num:num/p, den:den/p};
}

function fractionLatex(num, den){
  if(num===0) return "0";
  if(den===1) return num.toString();
  if(num<0) return `-\\frac{${Math.abs(num)}}{${den}}`;
  return `\\frac{${num}}{${den}}`;
}

function valFrac(f){ return f.num/f.den; }

function fractionDansBornes(f){
  return Math.abs(f.num)<=5 && Math.abs(f.den)<=5;
}

function afficheCoordonnee(num, den){
  // entier
  if (den === 1) {
    return num < 0 ? `(${num})` : `${num}`;
  }

  // fraction
  const frac = `\\frac{${Math.abs(num)}}{${den}}`;
  if (num < 0) return `(-${frac})`;
  return frac;
}


  /* =====================================================
   ENSEMBLE E CONTROLE (ANTI-DECIMAUX)
===================================================== */
const ENSEMBLE_E = [
  { num: 0, den: 1 },
  { num: 1, den: 1 },
  { num: 2, den: 1 },
  { num: 3, den: 1 },
  { num: 4, den: 1 },
  { num: 5, den: 1 },

  { num: 1, den: 2 },
  { num: 1, den: 3 },
  { num: 1, den: 4 },
  { num: 1, den: 5 },

  { num: 2, den: 3 },
  { num: 2, den: 5 },

  { num: 3, den: 2 },
  { num: 3, den: 4 },
  { num: 3, den: 5 },

  { num: 4, den: 3 },
  { num: 4, den: 5 }
];

function tirerE() {
  const base = ENSEMBLE_E[Math.floor(Math.random() * ENSEMBLE_E.length)];
  const signe = Math.random() < 0.5 ? -1 : 1;

  const num = signe * base.num;
  const den = base.den;

  return {
    num,
    den,
    valeur: num / den,                       // POUR LES CALCULS
    latex: den === 1 ? `${num}`: (num < 0 ? `-\\frac{${Math.abs(num)}}{${den}}`: `\\frac{${num}}{${den}}`)
  };
}

function tirerDansE(options = {}) {
  let obj;
  do {
    obj = tirerE();
  } while (
    (options.nonZero && obj.num === 0) ||
    (options.nonOne && Math.abs(obj.num) === obj.den)
  );
  return obj;
}

  
/* =====================================================
   GENERATEURS DE COEFFICIENTS
===================================================== */
function randIntNonZeroNotOne(){
  let x;
  do{
    x=Math.floor(Math.random()*11)-5;
  }while(x===0||x===1||x===-1);
  return x;
}

function randFractionNotOne(){
  let f;
  do{
    let num,den;
    do{
      num=Math.floor(Math.random()*11)-5;
      den=Math.floor(Math.random()*11)-5;
    }while(num===0||den===0);
    f=fractionIrreductible(num,den);
  }while(Math.abs(f.num)===Math.abs(f.den));
  return f;
}

function renderMath(el){
  MathJax.typesetClear([el]);
  MathJax.typesetPromise([el]);
}

function termeSigne(coef, contenu){
  if(coef === 0) return "";
  if(coef > 0) return `+ ${coef === 1 ? "" : coef}${contenu}`;
  return `- ${Math.abs(coef) === 1 ? "" : Math.abs(coef)}${contenu}`;
}

function termeConstante(c){
  if(c === 0) return "";
  return c > 0 ? `+ ${c}` : `- ${Math.abs(c)}`;
}

function afficheNombre(n){
  return n < 0 ? `(${n})` : `${n}`;
}

function termeAvecSigne(val){
  if(val === 0) return "0";
  return val > 0 ? `+ ${val}` : `- ${Math.abs(val)}`;
}

  function termeAvecSigneCorrection(val){
  if(val === 0) return "+ 0";
  return val > 0 ? `+ ${val}` : `- ${Math.abs(val)}`;
}

  function fractionAvecSigne(num, den){
  if (num === 0) return "+ 0";
  if (num > 0) return `+ \\frac{${num}}{${den}}`;
  return `- \\frac{${Math.abs(num)}}{${den}}`;
}

  function fractionSansPlus(num, den){
  if (num === 0) return "0";
  if (num > 0) return `\\frac{${num}}{${den}}`;
  return `-\\frac{${Math.abs(num)}}{${den}}`;
}

  
/* =====================================================
   VARIABLES
===================================================== */
let appartient=false;
let texteCorrection="";
let dernierEnonceHTML = "";

/* =====================================================
   GENERATION EXERCICE
===================================================== */

let generationOK = true;

function generer(){
  generationOK = true;   // ‚Üê OBLIGATOIRE
  appartient = Math.random() < 0.4; // 40% de oui, 60% de non
  const tirage=Math.random();
  let enonce="";
  let e,f;

/* ==================== 
  CAS 1 : y = mx + p 
===================== */
if(tirage<0.4){

const mObj = tirerDansE({ nonZero: true, nonOne: true });
const pObj = tirerDansE();

const m = { num: mObj.num, den: mObj.den };
const p = { num: pObj.num, den: pObj.den };


let essais = 0;
let eAff;
let eObj;
let yF;   // ‚Üê D√âCLARATION ICI

do {
eObj = tirerE();
const eNum = eObj.num;    
const eDen = eObj.den;   
eAff = eObj.latex;


yF = fractionIrreductible(
  m.num * eNum * p.den + p.num * m.den * eDen,
  m.den * eDen * p.den
);


  f = fractionLatex(yF.num, yF.den);
  essais++;
  if (essais > 50) break;
} while (
  appartient &&
  (Math.abs(yF.num) > 20 || Math.abs(yF.den) > 10)
);

  
if (!appartient) {
  if (Math.random() < 0.5) {
    // entier faux
    f = yF.num + 1;
  } else {
    // fraction fausse
    const faux = tirerE();
    f = fractionLatex(faux.num, faux.den);
  }
}


const eqDroite =
  p.num === 0
    ? `y = ${fractionLatex(m.num, m.den)}x`
    : `y = ${fractionLatex(m.num, m.den)}x ${
        p.num > 0 ? "+ " : "- "
      }${fractionLatex(Math.abs(p.num), p.den)}`;

enonce = `
La droite a pour √©quation :<br>
\\(${eqDroite}\\)<br><br>
Le point \\(A(${eAff};${f})\\) appartient-il √† cette droite ?
`;


/* ===== CORRECTION DETAILLEE : y = mx + p ===== */

// ---------- Donn√©es ----------
const mNum = m.num;
const mDen = m.den;
const pNum = p.num;
const pDen = p.den;
const pEstNul = (pNum === 0);

  
// y du point (f) (doit correspondre √† l'affichage)
let yCorr;

if (typeof f === "string") {
  // f est une fraction latex ‚Üí on reconstruit num/den
  const match = f.match(/-?\\frac\{(\d+)\}\{(\d+)\}|-?\d+/);
  if (match) {
    if (match[1]) {
      const signe = f.startsWith("-") ? -1 : 1;
      yCorr = { num: signe * parseInt(match[1]), den: parseInt(match[2]) };
    } else {
      yCorr = { num: parseInt(f), den: 1 };
    }
  }
} else {
  yCorr = { num: f, den: 1 };
}


// ---------- Affichage s√©curis√© de x ----------
let xAff = eAff;
if (eObj && eObj.valeur < 0) {
  xAff = `(${eAff})`;
}

// ---------- √âtape 1 : substitution ----------
let texte = `
<u>√âtape 1</u> : on remplace les coordonn√©es du point A dans l‚Äô√©quation<br>
\\[
${fractionLatex(yCorr.num, yCorr.den)}
\\stackrel{?}{=}
${fractionLatex(mNum, mDen)} \\cdot ${xAff}
${pNum === 0 ? "" : (pNum > 0 ? "+ " : "- ") + fractionLatex(Math.abs(pNum), pDen)}
\\]
`;

// ---------- √âtape 2 : calcul de m¬∑x (avec simplification) ----------
const mxNum = mNum * eObj.num;
const mxDen = mDen * eObj.den;

let mx;
let mxEstFraction = false;

if (mxDen === 1) {
  mx = mxNum;
} else if (Math.abs(mxNum) % mxDen === 0) {
  mx = mxNum / mxDen;
} else {
  mx = fractionIrreductible(mxNum, mxDen);
  mxEstFraction = true;
}

texte += `
<u>√âtape 2</u> : on effectue et/ou on simplifie le produit<br>
\\[
${fractionLatex(yCorr.num, yCorr.den)}
\\stackrel{?}{=}
${
  mxEstFraction
    ? fractionLatex(mx.num, mx.den)
    : mx
}
${pNum === 0 ? "" : (pNum > 0 ? "+ " : "- ") + fractionLatex(Math.abs(pNum), pDen)}
\\]
`;

// ---------- √âtape 3 : addition ----------
if (!mxEstFraction && pDen === 1) {

  // tout est entier
  const somme = mx + pNum;

  texte += `
<u>√âtape 3</u> : on additionne et on compare<br>
\\[
${fractionLatex(yCorr.num, yCorr.den)}
${somme === yCorr.num ? "=" : "\\neq"}
${somme}
\\]
`;

  texte += somme === yCorr.num
    ? `<br>üëâ Le point <strong>appartient</strong> √† la droite.`
    : `<br>üëâ Le point <strong>n'appartient pas</strong> √† la droite.`;

} else {

// ---------- √âtape 3 : mise sur le m√™me d√©nominateur ----------
const den = ppcmListe([
  mxEstFraction ? mx.den : 1,
  pEstNul ? 1 : pDen
]);
const n1 = mxEstFraction ? mx.num : mx * den;
const n2 = pEstNul ? 0 : pNum * (den / pDen);
somme = fractionIrreductible(n1 + n2, den);
sommeEstFraction = true;
  
texte += `
<u>√âtape 3</u> : on met les termes de droite sur le m√™me d√©nominateur<br>
\\[
${fractionLatex(yCorr.num, yCorr.den)}
\\stackrel{?}{=}
${fractionLatex(n1, den)}
${pNum === 0 ? "" : fractionAvecSigne(n2, den)}
\\]
`;

// ---------- √âtape 4 : addition des num√©rateurs ----------
const egalite = sommeEstFraction
  ? (somme.num === yCorr.num && somme.den === yCorr.den)
  : (somme === yCorr.num);

texte += `
<u>√âtape 4</u> : on compare<br>
\\[
${fractionLatex(yCorr.num, yCorr.den)}
${egalite ? "=" : "\\neq"}
${sommeEstFraction ? fractionLatex(somme.num, somme.den) : somme}
\\]
`;

texte += egalite
  ? `<br>üëâ Le point <strong>appartient</strong> √† la droite.`
  : `<br>üëâ Le point <strong>n'appartient pas</strong> √† la droite.`;

}

texteCorrection = texte;

}

/* ==================
    CAS 2 : x = k
==================== */
  
else if(tirage<0.6){

const k = randFractionNotOne();
f = Math.floor(Math.random() * 7) - 3;

let eObj;
let eAff;

if (appartient) {
  // le point appartient : e = k
  eObj = { num: k.num, den: k.den, valeur: k.num / k.den };
  eAff = fractionLatex(k.num, k.den);
} else {
  // le point n'appartient pas : e ‚â† k
  do {
    eObj = tirerE();
  } while (eObj.num === k.num && eObj.den === k.den);

  eAff = eObj.latex;
}

enonce = `
La droite a pour √©quation :<br>
\\(x = ${fractionLatex(k.num,k.den)}\\)<br><br>
Le point \\(A(${eAff};${f})\\) appartient-il √† cette droite ?
`;


  /* ===== CORRECTION DETAILLEE : x = k ===== */

const kAff = fractionLatex(k.num, k.den);

// ===== √âtape 1 : substitution =====
let texte = `
<u>√âtape 1</u> : on remplace l‚Äôabscisse du point A dans l‚Äô√©quation<br>
\\[
${eAff} \\stackrel{?}{=} ${kAff}
\\]
`;

// ===== √âtape 2 : comparaison =====
const egalite = eObj.valeur === k.num / k.den;

texte += `
<u>√âtape 2</u> : on compare<br>
\\[
${eAff} ${egalite ? "=" : "\\neq"} ${kAff}
\\]
`;

// ===== Conclusion =====
texte += egalite
  ? `<br>üëâ Le point <strong>appartient</strong> √† la droite.`
  : `<br>üëâ Le point <strong>n'appartient pas</strong> √† la droite.`;

texteCorrection = texte;

}

/* ============================ 
    CAS 3 : ax + by + c = 0 
=========================== */
else {

  const a = randIntNonZeroNotOne();
  const b = randIntNonZeroNotOne();
  const c = randIntNonZeroNotOne();

  let yF;
  let essais = 0;
  let eAff;
  let eObj;
  
  do {
    eObj = tirerE();
    e = eObj.valeur;           // calcul
    eAff = eObj.latex;   // affichage

    yF = fractionIrreductible(-a * e - c, b);

    f = fractionLatex(yF.num, yF.den);
    essais++;
    if(essais > 50) break;
  } while(appartient && !fractionDansBornes(yF));

  if (appartient && !fractionDansBornes(yF)) {
  generationOK = false;
}
  
  if(!appartient){
    f = Math.floor(Math.random()*7) - 3;
  }



  let eq = "";
  eq += (a<0?"-":"") + (Math.abs(a)===1?"":Math.abs(a)) + "x";
  eq += " " + (b>=0?"+ ":"- ") + (Math.abs(b)===1?"":Math.abs(b)) + "y";
  eq += " " + (c>=0?"+ ":"- ") + Math.abs(c) + " = 0";

  enonce = `
  La droite a pour √©quation :<br>
  \\(${eq}\\)<br><br>
  Le point \\(A(${eAff};${f})\\) appartient-il √† cette droite ?
  `;


/* ===== CORRECTION DETAILLEE : ax + by + c = 0 ===== */

/* ===== PATCH S√õR : valeur de y pour la correction ===== */
let yCorr;
if (typeof f === "string") {
  yCorr = yF;                 // fraction affich√©e
} else {
  yCorr = { num: f, den: 1 }; // entier affich√©
}

// Affichage s√©curis√© de e pour l'√©tape 1 (parenth√®ses si e < 0)
let eAffEtape1 = eAff;

// entier n√©gatif
if (typeof e === "number" && e < 0) {
  eAffEtape1 = `(${eAff})`;
}

// fraction n√©gative (d√©j√† latex)
if (eObj && eObj.num < 0) {
  eAffEtape1 = `(${eAff})`;
}

let texte = `
<u>√âtape 1</u> : on remplace les coordonn√©es du point A dans l'√©quation<br>
\\[
${a}\\cdot ${eAffEtape1}
${termeAvecSigne(b)}\\cdot ${afficheCoordonnee(yCorr.num, yCorr.den)}
${termeAvecSigne(c)}
\\stackrel{?}{=} 0
\\]
`;
/* ===== √âtape 2 : on effectue et/ou on simplifie les produits ===== */

// produit a¬∑x
let axFraction;
let axEstFraction = false;

const axNum = a * eObj.num;
const axDen = eObj.den;

if (axDen === 1) {
  axFraction = axNum;                 // entier
} else if (Math.abs(axNum) % axDen === 0) {
  axFraction = axNum / axDen;         // entier simplifi√©
} else {
  axFraction = { num: axNum, den: axDen }; // fraction
  axEstFraction = true;
}



// produit b¬∑y
let byFraction;
let byEstFraction = false;

const byNum = b * yCorr.num;
const byDen = yCorr.den;

// simplification locale
if (byDen === 1) {
  byFraction = byNum;             // entier
} else if (Math.abs(byNum) % byDen === 0) {
  byFraction = byNum / byDen;     // entier simplifi√©
} else {
  byFraction = { num: byNum, den: byDen }; // fraction
  byEstFraction = true;
}


// ===== Affichage √âtape 2 =====
texte += `
<u>√âtape 2</u> : on effectue et/ou on simplifie les produits<br>
\\[
${
  axEstFraction
    ? fractionSansPlus(axFraction.num, axFraction.den)
    : axFraction
}
${
  byEstFraction
    ? fractionAvecSigne(byFraction.num, byFraction.den)
    : termeAvecSigneCorrection(byFraction)
}
${termeAvecSigne(c)}
\\stackrel{?}{=} 0
\\]
`;


// ===== √âtape 3 : addition directe ou fraction =====

if (!axEstFraction && !byEstFraction) {

  // tous les termes sont entiers
  const somme = axFraction + byFraction + c;

  texte += `
<u>√âtape 3</u> : on additionne et on compare √† z√©ro<br>
\\[
${somme} ${somme === 0 ? "=" : "\\neq"} 0
\\]
`;

  texte += somme === 0
    ? `<br>üëâ Le point <strong>appartient</strong> √† la droite.`
    : `<br>üëâ Le point <strong>n'appartient pas</strong> √† la droite.`;

} else {

  // il reste au moins une fraction
  let den;

  if (axEstFraction) {
    den = axFraction.den;
  } else {
    den = byFraction.den;
  }

  const n1 = axEstFraction ? axFraction.num : axFraction * den;
  const n2 = byEstFraction ? byFraction.num : byFraction * den;
  const n3 = c * den;

  texte += `
<u>√âtape 3</u> : il reste une fraction, on met sur le m√™me d√©nominateur<br>
\\[
${fractionSansPlus(n1, den)}
${fractionAvecSigne(n2, den)}
${fractionAvecSigne(n3, den)}
\\stackrel{?}{=} 0
\\]
`;

  const numFinal = n1 + n2 + n3;

  texte += `
<u>√âtape 4</u> : on additionne et on compare avec z√©ro<br>
\\[
${numFinal === 0 ? "0" : fractionLatex(Math.abs(numFinal), den)}
${numFinal === 0 ? "=" : "\\neq"} 0
\\]
`;

  texte += numFinal === 0
    ? `<br>üëâ Le point <strong>appartient</strong> √† la droite.`
    : `<br>üëâ Le point <strong>n'appartient pas</strong> √† la droite.`;
}


texteCorrection = texte;


}

if (!generationOK) {
  generer();
  return;
}

// emp√™cher deux √©nonc√©s identiques d'affil√©e
if (enonce === dernierEnonceHTML) {
  generer();
  return;
}

dernierEnonceHTML = enonce;
document.getElementById("enonce").innerHTML = enonce;
renderMath(document.getElementById("enonce"));
document.getElementById("reponse").value="";
document.getElementById("feedback").innerHTML="";
}

/* =====================================================
   VERIFICATION
===================================================== */
function verifier(){
  const r=document.getElementById("reponse").value.trim().toLowerCase();
  const f=document.getElementById("feedback");

  if(r!=="oui"&&r!=="non"){
    f.style.color="red";
    f.innerHTML="‚ùå Incorrect";
    return;
  }

  if((r==="oui")===appartient){
    f.style.color="green";
    f.innerHTML="‚úÖ Correct";
  }else{
    f.style.color="red";
    f.innerHTML="‚ùå Incorrect";
  }
}

/* =====================================================
   CORRECTION
===================================================== */
function corriger(){
  const f=document.getElementById("feedback");
  f.style.color="#000";
  f.innerHTML=`üìò <strong>Correction</strong><br><br>${texteCorrection}`;
  renderMath(f);
}

/* =====================================================
   INIT
===================================================== */
generer();
</script>

<script src="../../../js/protection.js"></script>

</body>
</html>
